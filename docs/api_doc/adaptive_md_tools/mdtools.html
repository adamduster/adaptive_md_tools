<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>adaptive_md_tools.mdtools API documentation</title>
<meta name="description" content="This is currently a set of classes that contains the bonding
topology and AP groups for the system" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>adaptive_md_tools.mdtools</code></h1>
</header>
<section id="section-intro">
<p>This is currently a set of classes that contains the bonding
topology and AP groups for the system</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python
&#34;&#34;&#34;
This is currently a set of classes that contains the bonding
topology and AP groups for the system
&#34;&#34;&#34;
__author__ = &#39;Adam Duster&#39;
__copyright__ = &#39;&#39;
__credits__ = [&#39;Adam Duster&#39;]
__license__ = &#39;CC-BY-SA&#39;
__version__ = &#39;0.1&#39;
__email__ = &#39;adam.duster@ucdenver.edu&#39;
__status__ = &#39;Development&#39;

import argparse
import sys
import numpy as np
from itertools import (takewhile,repeat)


__el2num = {&#39;H&#39;:1,
            &#39;O&#39;:8,
            &#39;C&#39;:6,
            &#39;N&#39;:7}
__num2el = {1:&#39;H&#39;,
            8:&#39;O&#39;,
            6:&#39;C&#39;,
            7:&#39;N&#39;}


class Bonds:
    &#34;&#34;&#34;
    A class to keep track of the bonding for system
    &#34;&#34;&#34;
    def __init__(self, numAtoms, bond_list=[]):
        self.numAtoms = numAtoms
        self.bonds = [[] for x in range(numAtoms)]
        self.numBonds = 0
        self.blist = []

        for b in bond_list:
            self.addBonds(b[0], b[1])
        return

    def addBonds(self, a1, a2):
        &#34;&#34;&#34;
        Add a bond to a1 and a2. This means a1 is added to a2&#39;s bonds and
        a2 is added to a1&#39;s bonds
        :param a1:
        :param a2:
        :return:
        &#34;&#34;&#34;
        if a2 in self.bonds[a1]:
            print(&#34;Cannot add bond, atom %d is already bonded to atom %d&#34;
                  % (a1, a2))
            raise RuntimeError

        if a1 in self.bonds[a2]:
            print(&#34;Cannot add bond, atom %d is already bonded to atom %d&#34;
                  % (a2, a1))
            raise RuntimeError

        if a1 == a2:
            print(&#34;Cannot bond atom to itself&#34;)
            raise RuntimeError
        self.bonds[a1].append(a2)
        self.bonds[a2].append(a1)
        self.numBonds += 1
        self.blist.append((a1,a2))
        return

    def printBonds(self, style=None):
        pBonds = self.getUniqueBonds()
        nBonds = len(pBonds)
        bLine = &#34;{0:9d}   {1:9d}&#34;
        psfLine = &#34;{0:8d}{1:8d}{2:8d}{3:8d}{4:8d}{5:8d}{6:8d}{7:8d}&#34;
        partLine = &#34;{0:8d}{1:8d}&#34;
        if not style:
            print(&#34;NBonds: &#34; + str(nBonds))
            for i in range(nBonds):
                print(bLine.format(*pBonds[i]))
        if style == &#39;psf&#39;:
            tBonds = []
            for i in pBonds:
                tBonds.append((i[0]+1, i[1]+1))
            pBonds = tBonds
            print(&#34;{0:8d} !NBONDS: bonds&#34;.format(nBonds))
            nLines = nBonds // 4
            b = 0
            for i in range(nLines):
                print(psfLine.format(*pBonds[b], *pBonds[b+1], *pBonds[b+2],
                                     *pBonds[b+3]))
                b += 4
            if nBonds % 4 &gt; 0:
                lastLine = &#34;&#34;
                for i in range(nBonds % 4):
                    lastLine += partLine.format(*pBonds[b])
                    b += 1
                print(lastLine)
        return

    def getUniqueBonds(self):
        uniqueBonds = []
        for i in range(self.numAtoms - 1):
            for j in self.bonds[i]:
                if j &gt; i:
                    uniqueBonds.append((i, j))
        return uniqueBonds


class Groups:
    &#34;&#34;&#34;
    A class to keep track of the AP group stuff
    &#34;&#34;&#34;
    def __init__(self, numGroups, numAtoms):
        self.numAtoms = numAtoms
        self.numGroups = numGroups
        self.atomGroups = np.full(numAtoms, -1, dtype=int)
        self.groupAtoms = [[] for x in range(numGroups)]
        self.groupReps = np.full(numGroups, -1, dtype=int)
        self.nonDefaultRepresentative = False

    def setAtomGroup(self, ind, group):
        &#34;&#34;&#34;
        Affiliate the atom with a group. If this is the first atom
        affiliated with the group, make it the group representative.
        :param ind: the atom index
        :param group: the group to affiliate atom with
        :return:
        &#34;&#34;&#34;
        if ind &gt; self.numAtoms - 1:
            print(&#34;Error, atom index out of range for setting group&#34;)
            raise IndexError
        if group &gt; self.numGroups - 1:
            print(&#34;Error, group index out of range for setting group&#34;)
        self.atomGroups[ind] = group
        if ind not in self.groupAtoms[group]:
            self.groupAtoms[group].append(ind)
            self.groupReps[group] = self.groupAtoms[group][0]
        else:
            print(&#34;Error, atom %d already in group %d&#34; % (ind, group))
            raise RuntimeError

        return

    def setGroupRep(self, ind, group):
        &#34;&#34;&#34;
        Set the group representative
        :param ind: atom index to make representative
        :param group: group to make representative of
        :return:
        &#34;&#34;&#34;
        if ind in self.groupAtoms[group]:
            self.groupAtoms[group].insert(0, self.groupAtoms[group].pop(
                self.groupAtoms[group].index(ind)))
            self.groupReps[group] = self.groupAtoms[group][0]
        else:
            &#34;Atom %d cannot be group representative because it is not in the&#34;
            &#34; group!&#34;
            raise RuntimeError
        return

    def checkGroups(self):
        &#34;&#34;&#34;
        Check to ensure all atoms are assigned to group and all groups have
        a representative atom. Return false if this is not the case
        :return: goodCheck = logical
        &#34;&#34;&#34;
        goodCheck = True
        # Check that groups all have a representative
        for i in range(self.numGroups):
            if not self.groupAtoms[i]:
                print(&#34;Group %d no atoms&#34; % i)
                goodCheck = False

        # Check that all atoms are assigned to group
        for i in range(self.numAtoms):
            if self.atomGroups[i] &lt; 0:
                print(&#34;Atom %d not assigned to group&#34; % i)
                goodCheck = False
        return goodCheck

    def printGroups(self, style=&#39;groups.log&#39;):
        header = &#39;# NGroups       NAtoms&#39;
        header2 = &#39;# Group       AtomIndex (both 1 based)&#39;
        outLine = &#39;{0:9d}    {1:9d}&#39;
        if style == &#39;groups.log&#39;:
            print(header)
            print(outLine.format(self.numGroups, self.numAtoms))
            print(header2)
            for i in range(self.numGroups):
                for j in range(len(self.groupAtoms[i])):
                    print(outLine.format(i + 1, self.groupAtoms[i][j] + 1))
            print(&#39;END&#39;)

    def transferAtom(self, atom, new_atom):
        &#34;&#34;&#34;
        Change the group of an atom specified by ATOM to the group of the atom
        specified by NEW_BOND
        :param atom:
        :param new_atom:
        :return:
        &#34;&#34;&#34;
        old_group = self.atomGroups[atom]
        new_group = self.atomGroups[new_atom]
        self.groupAtoms[old_group].remove(atom)
        self.groupAtoms[new_group].append(atom)
        self.atomGroups[atom] = new_group
        return


class Topology:
    def __init__(self, of_path=None, num_atoms=0):
        self.hello = True
        self.bonds = []
        self.psf_lines = []
        self.num_atoms = 0
        self.ofi = None
        if of_path:
            self.set_ofi(of_path)
        self.mm_types = MMTypes(1)
        # if num_atoms:
            # self.ind = np.arange(1, num_atoms + 1, 1)
            # self.segment = np.array(num_atoms, dtype=&#39;U4&#39;)
            # self.resid = np.array(num_atoms, dtype=int)
            # self.resname = np.array(num_atoms, dtype=&#39;U4&#39;)
            # self.atmname = np.array(num_atoms, dtype=&#39;U4&#39;)
        # self.ind = []
        # self.resid = []
        # self.segname = []
        # self.resname = []
        # self.atmname = []
        # self.atmtype = []
        # self.charge = []
        # self.mass = []


    def set_ofi(self, of_path):
        if self.ofi:
            self.ofi.close()
        else:
            self.ofi = open(of_path, &#39;w&#39;)

    def close_ofi(self):
        self.ofi.close()
        self.ofi = None

    def write_psf(self, bonds, num_atoms, start_lines=None):
        num_bonds = len(bonds)
        num_ang = 0
        num_dihed = 0
        num_imp = 0
        num_don = 0
        num_acc = 0
        num_nnb = 0
        bond_tstr = &#34;{0:8d} !NBOND: bonds\n&#34;
        ang_tstr = &#34;{0:8d} !NTHETA: angles\n&#34;
        dihed_tstr = &#34;{0:8d} !NPHI: angles\n&#34;
        imp_tstr = &#34;{0:8d} !NIMPHI: angles\n&#34;
        don_tstr = &#34;{0:8d} !NDON: angles\n&#34;
        acc_tstr = &#34;{0:8d} !NACC: angles\n&#34;
        nnb_tstr = &#34;{0:8d} !NNB: angles\n\n&#34;
        ngrp = &#34;{:8d}{:8d} !NGRP\n{:8d}{:8d}{:8d}\n&#34;.format(1,0,0,0,0)

        if start_lines:
            self.ofi.writelines(start_lines)
        else:
            self.write_title()
            self.write_natom()
        self.write_section(bond_tstr, bonds, 4)
        # Write angles
        self.ofi.write(ang_tstr.format(num_ang))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(dihed_tstr.format(num_dihed))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(imp_tstr.format(num_imp))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(don_tstr.format(num_don))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(acc_tstr.format(num_acc))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(nnb_tstr.format(num_nnb))
        self.ofi.write(&#39;\n\n&#39;)
        zeros = [[-1] for i in range(num_atoms)]
        self.write_section(nnb_tstr, zeros, 8)
        self.ofi.write(ngrp)
        self.close_ofi()

    def write_title(self):
        &#34;&#34;&#34;
        Write a title for the psf file
        :return:
        &#34;&#34;&#34;
        self.ofi.write(&#39;PSF\n\n&#39;)
        self.ofi.write(&#39;{0:8d} !NTITLE\n&#39;.format(1))
        self.ofi.write(&#39; REMARKS nothing\n\n&#39;)

    def write_natom(self):
        &#34;&#34;&#34;
        Write the mm atom types into the psf file
        :return:
        &#34;&#34;&#34;
        line = &#34;&#34;
        self.ofi.write(&#39;{:8d} !NATOM\n&#39;.format(self.mm_types.numAtoms))
        for i in range(self.mm_types.numAtoms):
            self.ofi.write(&#34;{:8d} &#34;    .format(i+1))
            self.ofi.write(&#34;{:4s} &#34;    .format(self.mm_types.segName[i]))
            self.ofi.write(&#34;{:&lt;4d} &#34;   .format(self.mm_types.resId[i]))
            self.ofi.write(&#34;{:4} &#34;     .format(self.mm_types.resName[i]))
            self.ofi.write(&#34;{:4} &#34;     .format(str(self.mm_types.atomName[i])))
            self.ofi.write(&#34;{:4} &#34;     .format(str(self.mm_types.atomType[i])))
            self.ofi.write(&#34;{:10.6f}  &#34;.format(self.mm_types.charge[i]))
            self.ofi.write(&#34;{:12.4f}&#34;  .format(self.mm_types.atomMass[i]))
            self.ofi.write(&#34;{:12d}\n&#34;  .format(0))
        self.ofi.write(&#39;\n&#39;)
        return

    def write_section(self, tstring, inds, groups_per_line):
        num_groups = len(inds)
        num_lines = num_groups // groups_per_line
        extra_bonds = num_groups % groups_per_line

        self.ofi.write(tstring.format(num_groups))
        g = 0
        gpl = groups_per_line
        for out_line in range(num_lines):
            my_str = self.make_str(inds[g:g+gpl])
            self.ofi.write(my_str)
            g += gpl
        if extra_bonds:
            my_str = self.make_str(inds[g:])
            self.ofi.write(my_str)
        self.ofi.write(&#39;\n\n&#39;)


    def make_str(self, inds, str_width=8):
        template = &#34;{:&#34; + str(str_width) + &#34;d}&#34;
        my_str = &#34;&#34;
        num_groups = len(inds)
        num_in_group = len(inds[0])
        for i in range(num_groups):
            for j in range(num_in_group):
                my_str += template
        my_str += &#39;\n&#39;
        flat_list = [item +1 for sublist in inds for item in sublist]
        return my_str.format(*flat_list)

    def write_mol2(self, bonds):


        self.ofi.write(&#39;@&lt;TRIPOS&gt;MOLECULE\n&#39;)
        self.ofi.write(&#39;*****\n&#39;)
        s = &#39; {0:d} {1:d} 0 0 0\n&#39;
        self.ofi.write(s.format(self.num_atoms, len(bonds)))
        self.ofi.write(&#39;SMALL\nGASTEIGER\n\n&#39;)
        self.write_atom()
        self.write_bond(bonds)
        self.close_ofi()

    def write_atom(self):
        self.ofi.write(&#39;@&lt;TRIPOS&gt;ATOM\n&#39;)
        atmstr = &#39;{0:7d} {1:2}          0.0000    0.0000    0.0000 {2:4} {5:&gt;4}  {3:5}       {4:7.4f}\n&#39;
        for i in range(self.mm_types.numAtoms):
            self.ofi.write(atmstr.format(i+1,
                                         self.mm_types.element[i],
                                         str(self.mm_types.atomType[i]),
                                         str(self.mm_types.atomName[i]),
                                         self.mm_types.charge[i],
                                         str(self.mm_types.resId[i])))
    def write_bond(self, bonds):
        self.ofi.write(&#39;@&lt;TRIPOS&gt;BOND\n&#39;)
        s = &#39;{:6d}{:6d}{:6d}{:6d}\n&#39;
        for i in range(len(bonds)):
            self.ofi.write(s.format(i+1, bonds[i][0]+1, bonds[i][1]+1, 1))


class MMTypes:
    def __init__(self, numAtoms):
        self.numAtoms = numAtoms
        self.strWidth = 4
        sid = &#34;U%d&#34; % self.strWidth
        self.segName = np.zeros(numAtoms, dtype=sid)
        self.resId = np.zeros(numAtoms, dtype=int)
        self.resName = np.zeros(numAtoms, dtype=sid)
        self.charge = np.zeros(numAtoms, dtype=float)
        self.atomName = np.zeros(numAtoms, dtype=sid)
        self.atomType = np.zeros(numAtoms, dtype=sid)
        self.atomMass = np.zeros(numAtoms, dtype=float)
        self.element = np.zeros(numAtoms, dtype=&#39;U2&#39;)


class File:
    def __init__(self, filePath, fileType=&#39;&#39;):
        try:
            self.ifi = open(filePath, &#39;r&#39;)
            self.path = filePath
        except FileNotFoundError:
            print(&#34;Cannot open {0} file: &#34;.format(fileType) + filePath)
            sys.exit()


class Mol2File(File):
    def getTopo(self):
        topo = Topology()
        topo.mm_types = self.getMMTypes()
        topo.num_atoms = topo.mm_types.numAtoms
        topo.bonds = self.getBonds()
        return topo

    def getNumAtoms(self):
        self.ifi.seek(0)
        while True:
            line = self.ifi.readline()
            words = line.split()
            if &#39;MOLECULE&#39; in line:
                line = self.ifi.readline()
                words = self.ifi.readline().split()
                return int(words[0]), int(words[1])
        print(&#34;Could not find number of atoms&#34;)
        raise ValueError

    def getMMTypes(self):
        numAtoms, numBonds = self.getNumAtoms()
        mmNames = MMTypes(numAtoms)
        self.ifi.seek(0)
        found_atoms = False
        while True:
            line = self.ifi.readline()
            if not line:
                break
            if &#39;ATOM&#39; in line.upper() and not found_atoms:
                self.read_atom(mmNames)
                found_atoms = True
        if not found_atoms:
            print(&#34;Error, could not find ATOM section&#34;)
            raise LookupError
        return mmNames


    def getBonds(self):
        numAtoms, numBonds = self.getNumAtoms()
        bonds = Bonds(numAtoms)
        self.ifi.seek(0)
        found_bonds = False
        while True:
            line = self.ifi.readline()
            if not line:
                break
            if &#39;BOND&#39; in line.upper() and not found_bonds:
                self.read_bonds(bonds, numBonds)
                found_bonds = True
        if not found_bonds:
            print(&#34;Error, could not find bonds&#34;)
            raise LookupError
        return bonds

    def read_atom(self, mmType):
        for i in range(mmType.numAtoms):
            line = self.ifi.readline()
            words = line.split()
            mmType.element[i] = words[1]
            mmType.atomType[i] = words[5]
            mmType.atomName[i] = words[7]
            mmType.charge[i] = float(words[8])

    def read_bonds(self, bonds, numBonds):
        for i in range(numBonds):
            line = self.ifi.readline()
            words = line.split()
            bonds.addBonds(int(words[1])-1, int(words[2])-1)


class PDBFile(File):
    def __init__(self, pdbPath, required=None):
        File.__init__(self, pdbPath, &#39;pdb&#39;)
        self.required = required  # required fields to parse
        self.numAtoms = 0

    def parsePDB(self):
        serial = []
        name = []
        altLoc = []
        resName = []
        chainID = []
        resSeq = []
        iCode = []
        x = []
        y = []
        z = []
        occupancy, tempFactor, element, charge = [], [], [], []

        while True:
            line = self.ifi.readline()
            if not line:
                break
            if len(line) &lt; 6: continue
            if (&#39;ATOM&#39; in line[:6].upper()) or (&#39;HETATM&#39; in line[:6].upper()):
                break
        while line.lstrip()[:3].upper() != &#39;END&#39;:
            try:
                serial.append(int(line[6:11]))
            except:
                pass
            try:
                name.append(line[12:16])
            except:
                pass
            try:
                altLoc.append(line[16])
            except:
                pass
            try:
                resName.append(line[17:20])
            except:
                pass
            try:
                chainID.append(line[21])
            except:
                pass
            try:
                resSeq.append(line[22:26])
            except:
                pass
            try:
                iCode.append(line[26])
            except:
                pass
            try:
                x.append(float(line[30:38]))
            except:
                pass
            try:
                y.append(float(line[38:46]))
            except:
                pass
            try:
                z.append(float[line[46:54]])
            except:
                pass
            try:
                occupancy.append(float(line[54:60]))
            except:
                pass
            try:
                tempFactor.append(float(line[60:66]))
            except:
                pass
            try:
                element.append(line[76:78].strip())
            except:
                if &#39;element&#39; in self.required:
                    print(&#34;Error, could not parse element from pdb &#34;+ self.path)
                    sys.exit()
            try:
                charge.append(line[78:80])
            except:
                pass

            self.numAtoms += 1
            line = self.ifi.readline()

        element = np.asarray(element)
        return element


class PSFFile:
    def __init__(self, psfPath):
        try:
            self.ifi = open(psfPath, &#39;r&#39;)
        except FileNotFoundError:
            print(&#34;Cannot find psf file: &#34; + psfPath)
            sys.exit()

    def getNumAtoms(self):
        &#34;&#34;&#34;
        Read the number of atoms from the PSF file
        This leave the file at the NATOM line! Rewind it if you need to
        go from beginning and don&#39;t change because other programs depend
        on it!
        :return:
        &#34;&#34;&#34;
        self.ifi.seek(0)
        natoms = 0
        while True:
            line = self.ifi.readline()
            if not line:
                break
            if &#34;!NATOM&#34; in line:
                try:
                    natoms = int(line.split()[0])
                    break
                except IOError:
                    print(&#34;Cannot read natoms from psf file&#34;)
                    sys.exit()
        if natoms == 0:
            print(&#34;Could not find NATOM in psf file&#34;)
            raise IOError

        return natoms

    def getTopo(self):
        topo = Topology()
        topo.mm_types = self.getMMTypes()
        topo.num_atoms = topo.mm_types.numAtoms
        return topo


    def getBonds(self):
        numAtoms = self.getNumAtoms()
        bonds = Bonds(numAtoms)
        self.ifi.seek(0)
        foundNBond = False
        while True:
            line = self.ifi.readline()
            if not line:
                break
            if &#34;!NBOND&#34; in line:
                foundNBond = True
                break

        if not foundNBond:
            print(&#34;Could not find NBonds section in psf file&#34;)
            raise IOError

        try:
            nbonds = int(line.split()[0])
        except IOError:
            print(&#34;Cannot read Nbonds&#34;)
            sys.exit()

        bondLines = nbonds // 4
        if nbonds % 4 &gt; 0:
            bondLines += 1

        foundBonds = 0

        for l in range(bondLines):
            line = self.ifi.readline()
            words = line.split()
            nwords = len(words)
            nowBonds = nwords // 2
            for i in range(nowBonds):
                a1 = int(words[i * 2]) - 1
                a2 = int(words[i * 2 + 1]) - 1
                bonds.addBonds(a1, a2)
                foundBonds += 1

        if foundBonds != nbonds:
            print(&#34;Did not find all of the bonds!&#34;)
            raise RuntimeError

        return bonds

    def read_beginning_lines(self):
            lines = []
            self.ifi.seek(0)
            line = &#34;&#34;
            found = False
            while found == False:
                line = self.ifi.readline()
                if &#34;!NBOND&#34; not in line:
                    lines.append(line)
                else:
                    found = True
            if not found:
                print(&#34;Error parsing PSF file for lines&#34;)
            return lines


    def getMMTypes(self):
        numAtoms = self.getNumAtoms()
        mmNames = MMTypes(numAtoms)
        for i in range(numAtoms):
            try:
                line = self.ifi.readline()
                words = line.split()
            except IOError:
                print(&#34;Error reading line %d in psf file&#34; % i)
                sys.exit(&#39;mmtypes 1&#39;)

            if len(words) != 9:
                print(&#34;Error, not enough data in psf file for atom %d &#34; % i)
                sys.exit(&#39;mmtypes 2&#39;)

            try:
                mmNames.segName[i] = words[1]
            except IOError:
                print(&#34;Error reading segname&#34;)
                sys.exit(&#39;mmtypes 3&#39;)
            try:
                mmNames.resId[i] = int(words[2])
            except IOError:
                print(&#34;Error reading residue index&#34;)
                sys.exit(&#39;mmtypes 4&#39;)
            try:
                mmNames.resName[i] = words[3]
            except IOError:
                print(&#34;Error reading resdue name&#34;)
                sys.exit(&#39;mmtypes 5&#39;)
            try:
                mmNames.atomName[i] = words[4]
            except IOError:
                print(&#34;Error reading atom name&#34;)
                sys.exit(&#39;mmtypes 6&#39;)
            try:
                mmNames.atomType[i] = words[5]
            except IOError:
                print(&#34;Error reading atom type&#34;)
                sys.exit(&#39;mmtypes 7&#39;)
            try:
                mmNames.charge[i] = float(words[6])
            except IOError:
                print(&#34;Error reading charge&#34;)
                sys.exit(&#39;mmtypes 8&#39;)
            try:
                mmNames.atomMass[i] = float(words[7])
            except IOError:
                print(&#34;Error reading atom mass&#34;)
                sys.exit(&#39;mmtypes 9&#39;)

            except IOError:
                print(&#34;Error reading psf at atom %d&#34; % i)
                sys.exit()
        return mmNames


class GroupsFile:
    def __init__(self, groupsPath):
        try:
            self.ifi = open(groupsPath, &#39;r&#39;)
            self.groupsPath = groupsPath
        except FileNotFoundError:
            print(&#34;Cannot find groups file: &#34; + groupsPath)
            sys.exit()

    def getGroups(self):

        # Read the number of groups, then number of atoms from the groups file
        try:
            line = _rLine(self.ifi)
            numGroups, numAtoms = [int(i) for i in line.split()[:2]]
        except IOError:
            print(&#34;Error reading number of groups and atoms from groups file: &#34;
                  + self.groupsPath)
            sys.exit()

        # Initialize the groups structure
        groups = Groups(numGroups, numAtoms)

        # Fill up the groups
        while True:
            line = _rLine(self.ifi)
            if not line:
                print(&#39;Error reading groups file, &#34;END&#34; not encountered&#39;)
                raise IOError
            words = line.split()
            if words[0].upper() == &#39;END&#39;:
                break

            group = int(words[0]) - 1
            ind = int(words[1]) - 1
            groups.setAtomGroup(ind, group)

        # Exit if there is anything left over
        if not groups.checkGroups():
            print(&#34;Error, not all groups or atoms were in groups file&#34;)
            raise RuntimeError

        return groups


def _rLine(ifi):
    &#34;&#34;&#34;
    By Adam Duster, Oct 12, 2017
    Read a line. Skip the line if there is a comment sign (#). If the line
    fails to read, raise an exception to be handeled by the calling program
    &#34;&#34;&#34;
    while True:
        line = ifi.readline()
        if not line:
            raise EOFError

        # skip comment
        if line.strip().startswith(&#39;#&#39;):
            continue
        else:
            return line


def get_args(args=None):
    &#34;&#34;&#34; This is written as a default funtion to put at beginning of all Python
    scripts which require command line arguments. This uses the argparse module
    which must be declared in the main program to ensure that the object is able
    to be used by the caller
    --Adam Duster 21 June 2017
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser(description=&#39;see header of python script&#39;)
    parser.add_argument(
        &#39;-i&#39;,
        &#39;--input&#39;,
        help=&#39;Input file name&#39;,
        required=True)
    parser.add_argument(
        &#39;-v&#39;,
        &#39;--verbose&#39;,
        help=&#39;Controls the level of output, use multipe v for more output&#39;,
        required=False,
        action=&#39;count&#39;,
        default=0)
    parser.add_argument(
        &#39;-c&#39;,
        &#39;--center&#39;,
        help=&#39;atom index to be moved to center&#39;,
        required=True,
        type=int
    )
    parser.add_argument(
        &#39;-x&#39;,
        &#39;--x&#39;,
        help=&#39;x length&#39;,
        required=True,
        type=float
    )
    parser.add_argument(
        &#39;-y&#39;,
        &#39;--y&#39;,
        help=&#39;y length&#39;,
        required=True,
        type=float
    )
    parser.add_argument(
        &#39;-z&#39;,
        &#39;--z&#39;,
        help=&#39;z length&#39;,
        required=True,
        type=float
    )
    parser.add_argument(
        &#39;-d&#39;,
        &#39;--debug&#39;,
        help=&#39;Enter debug mode&#39;,
        required=False,
        action=&#39;store_true&#39;,
        default=False)
    parser.add_argument(
        &#39;--psf&#39;,
        help=&#34;PSF file path for reading bonds&#34;,
        required=False,
        default=None
    )
    return parser.parse_args(args)


def read_xyz(ifpath, return_coord_array=False):
    &#34;&#34;&#34;
    Reads an xyz file
    :param ifpath:
    :return: num_atoms, x, y, z, atom_type, title as numpy int or float arrays
    &#34;&#34;&#34;
    with open(ifpath) as ifi:
        try:
            num_atoms = int(ifi.readline())
        except RuntimeError:
            raise RuntimeError(&#34;Error reading n atoms&#34;)

        title = ifi.readline()
        x = np.zeros(num_atoms, dtype=float)
        y = np.zeros(num_atoms, dtype=float)
        z = np.zeros(num_atoms, dtype=float)
        atom_type = [&#39;&#39;] * num_atoms
        for i in range(num_atoms):
            line = ifi.readline()
            words = line.split()
            atom_type[i] = words[0]
            x[i] = float(words[1])
            y[i] = float(words[2])
            z[i] = float(words[3])
            if atom_type[i] == &#39;OH2&#39;:
                atom_type[i] = &#39;O&#39;
            elif atom_type[i] == &#39;H1&#39; or atom_type[i] == &#39;H2&#39;\
                    or atom_type[i] == &#39;H3&#39;:
                atom_type[i] = &#39;H&#39;
    if return_coord_array:
        return num_atoms, np.stack((x,y,z), axis=-1), atom_type, title
    return num_atoms, x, y, z, atom_type, title


def read_xyz2(ifpath):
    &#34;&#34;&#34;
    Reads an xyz file and returns numpy array and atomic numbers from element
    :param ifpath:
    :return: num_atoms, coords, atom_type, atom_number as numpy int or float
    :rtype: (np.ndarray(n, dtype=int16), np.ndarray(n,3, dtype=float),
    np.ndarray(n, dtype=&#34;U2&#34;), np.ndarray(n, dtype=int8)
    &#34;&#34;&#34;
    el_dict = {&#39;H&#39;:1, &#39;C&#39;:6, &#39;N&#39;:7, &#39;O&#39;:8}
    num_dict = {1:&#39;H&#39;, 6:&#39;C&#39;, 7:&#39;N&#39;, 8:&#39;O&#39;}
    with open(ifpath) as ifi:
        try:
            num_atoms = np.int16(ifi.readline())
        except:
            sys.exit(&#34;Error reading n atoms&#34;)
        coords = np.zeros((num_atoms,3), dtype=float)
        atom_type = np.zeros(num_atoms, dtype=&#34;U2&#34;)
        atomic_number = np.zeros(num_atoms, dtype=np.int8)
        ifi.readline()
        for i in range(num_atoms):
            line = ifi.readline()
            words = line.split()
            atom_type[i] = words[0]
            coords[i, 0] = float(words[1])
            coords[i, 1] = float(words[2])
            coords[i, 2] = float(words[3])
        if atom_type[i][0].isdigit():
            for i, el in enumerate(atom_type):
                atomic_number[i] = int(atom_type[i])
                atom_type[i] = num_dict[atomic_number[i]]

    return num_atoms, coords, atom_type


def read_xyz_trajectory(ifpath):
    &#34;&#34;&#34;
    Reads an xyz file
    :param ifpath:
    :return: num_atoms, x, y, z, atom_type, title as numpy int or float arrays
    &#34;&#34;&#34;
    with open(ifpath) as ifi:
        try:
            num_atoms = int(ifi.readline())
        except RuntimeError:
            raise RuntimeError(&#34;Error reading n atoms&#34;)
        nlines = rawincount(ifpath)
        if nlines % (num_atoms + 2) != 0:
            raise RuntimeError(&#34;Improper number of lines in trajectory&#34;)
        nframes = nlines//(num_atoms+2)

        title = ifi.readline()
        coords = np.zeros((nframes, num_atoms, 3), dtype=float)
        atom_type = [&#39;&#39;] * num_atoms
        ifi.seek(0)
        for f in range(nframes):
            line = ifi.readline()
            line = ifi.readline()
            for i in range(num_atoms):
                line = ifi.readline()
                words = line.split()
                try:
                    atom_type[i] = words[0]
                    coords[f, i, 0] = float(words[1])
                    coords[f, i, 1] = float(words[2])
                    coords[f, i, 2] = float(words[3])
                except:
                    print(&#34;Error reading xyz trajectory at frame %d&#34; % f)
                    print(&#34;Current line:&#34;)
                    print(line)
                    sys.exit()
                if atom_type[i] == &#39;OH2&#39;:
                    atom_type[i] = &#39;O&#39;
                elif atom_type[i] == &#39;H1&#39; or atom_type[i] == &#39;H2&#39;\
                        or atom_type[i] == &#39;H3&#39;:
                    atom_type[i] = &#39;H&#39;
    return num_atoms, coords, atom_type, title


def rawincount(filename):
    &#34;&#34;&#34;
    Get the number of lines in filename
    :param filename:
    :return:
    &#34;&#34;&#34;
    f = open(filename, &#39;rb&#39;)
    bufgen = takewhile(lambda x: x, (f.raw.read(1024*1024) for _ in repeat(None)))
    return sum( buf.count(b&#39;\n&#39;) for buf in bufgen )


def wrap_coords(cell_x, cell_y, cell_z, x, y, z, num_atoms, center):
    &#34;&#34;&#34;
    1. Translate all atoms by vector from atom designated by center
    to center of box defined by [[0, cell_x],[0, cell_y], [0, cell_z]]
    2. wrap all atoms outside of the above box into the box

    :param cell_x: x cell dimention float
    :param cell_y: y cell dimention float
    :param cell_z: float z cell dimension
    :param x: np float array x coords
    :param y: np float array y coords
    :param z: np float array z coords
    :param num_atoms: int
    :param center: int 0-based index of atom center
    :return: x, y, z
    &#34;&#34;&#34;
    def wrap_dimension(x, cell_x):
        no_wraps = False
        while not no_wraps:
            no_wraps = True
            for i in range(x.size):
                if x[i] &lt; 0:
                    x[i] += cell_x
                    no_wraps = False
                elif x[i] &gt; cell_x:
                    x[i] -= cell_x
                    no_wraps = False
        return x



    # Find the translation vector to shift all atoms by the vector
    # from the desired centers coords to the new center
    center_a_coords = np.asarray([x[center], y[center], z[center]])
    new_center = np.asarray([cell_x/2., cell_y/2., cell_z/2.])
    translation = new_center - center_a_coords

    x[:] += translation[0]
    y[:] += translation[1]
    z[:] += translation[2]


    # Now wrap the atoms
    x = wrap_dimension(x, cell_x)
    y = wrap_dimension(y, cell_y)
    z = wrap_dimension(z, cell_z)
    return x, y, z


def print_xyz(num_atoms, x, y, z, atom_type, title=None, ofi=None):
    print(num_atoms, file=ofi)
    if title:
        print(title[:-1], file=ofi)
    else:
        print(&#34;&#34;, file=ofi)
    l = &#34;{0:2}    {1:10.6f}    {2:10.6f}    {3:10.6f}&#34;
    for i in range(num_atoms):
        print(l.format(atom_type[i], x[i],y[i], z[i]), file=ofi)
    pass


def print_xyz_traj(coords, types, title=None, ofi=None):
    &#34;&#34;&#34;
    Write an xyz trajectory file to ofi
    :param coords: float ndarray with size [f,num_atoms,3] where f is num frames
    :param types: elements
    :param title: title for each frame
    :param ofi: open file handle for writing
    :return:
    &#34;&#34;&#34;
    num_atoms = coords.shape[1]
    for f in range(coords.shape[0]):
        print_xyz(num_atoms, coords[f,:,0], coords[f,:,1], coords[f,:,2],
                  types, title=title, ofi=ofi)


def get_elements(in_path, file_type):

    if file_type == &#39;xyz&#39;:
        _,_,_,_,elements,_ = read_xyz(in_path)
    elif file_type == &#39;pdb&#39;:
        pdbFile = PDBFile(in_path)
        elements = pdbFile.parsePDB()
    return np.asarray(elements)


def testPSFBonds(psfPath=&#39;./test_files/h3o.psf&#39;):
    psf = PSFFile(psfPath)
    bonds = psf.getBonds()
    bonds.printBonds(style=&#39;psf&#39;)


def testGroups(groupsPath=&#39;./test_files/groups.log&#39;):
    gFile = GroupsFile(groupsPath)
    groups = gFile.getGroups()
    groups.printGroups()

# ifpath = args.input
# cell_x = args.x
# cell_y = args.y
# cell_z = args.z
# center = args.center
# verbose = args.verbose
# debug = args.debug
#
# num_atoms, x, y, z, atom_type, title = read_xyz(ifpath)
# x, y, z = wrap_coords(cell_x, cell_y, cell_z, x, y, z, num_atoms, center)
# print_xyz(num_atoms, x, y, z, atom_type, title)


def main():
    arg_vals = None
    args = get_args(arg_vals)


if __name__ == &#34;__main__&#34;:
    testGroups()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="adaptive_md_tools.mdtools.get_args"><code class="name flex">
<span>def <span class="ident">get_args</span></span>(<span>args=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This is written as a default funtion to put at beginning of all Python
scripts which require command line arguments. This uses the argparse module
which must be declared in the main program to ensure that the object is able
to be used by the caller
&ndash;Adam Duster 21 June 2017</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_args(args=None):
    &#34;&#34;&#34; This is written as a default funtion to put at beginning of all Python
    scripts which require command line arguments. This uses the argparse module
    which must be declared in the main program to ensure that the object is able
    to be used by the caller
    --Adam Duster 21 June 2017
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser(description=&#39;see header of python script&#39;)
    parser.add_argument(
        &#39;-i&#39;,
        &#39;--input&#39;,
        help=&#39;Input file name&#39;,
        required=True)
    parser.add_argument(
        &#39;-v&#39;,
        &#39;--verbose&#39;,
        help=&#39;Controls the level of output, use multipe v for more output&#39;,
        required=False,
        action=&#39;count&#39;,
        default=0)
    parser.add_argument(
        &#39;-c&#39;,
        &#39;--center&#39;,
        help=&#39;atom index to be moved to center&#39;,
        required=True,
        type=int
    )
    parser.add_argument(
        &#39;-x&#39;,
        &#39;--x&#39;,
        help=&#39;x length&#39;,
        required=True,
        type=float
    )
    parser.add_argument(
        &#39;-y&#39;,
        &#39;--y&#39;,
        help=&#39;y length&#39;,
        required=True,
        type=float
    )
    parser.add_argument(
        &#39;-z&#39;,
        &#39;--z&#39;,
        help=&#39;z length&#39;,
        required=True,
        type=float
    )
    parser.add_argument(
        &#39;-d&#39;,
        &#39;--debug&#39;,
        help=&#39;Enter debug mode&#39;,
        required=False,
        action=&#39;store_true&#39;,
        default=False)
    parser.add_argument(
        &#39;--psf&#39;,
        help=&#34;PSF file path for reading bonds&#34;,
        required=False,
        default=None
    )
    return parser.parse_args(args)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.get_elements"><code class="name flex">
<span>def <span class="ident">get_elements</span></span>(<span>in_path, file_type)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_elements(in_path, file_type):

    if file_type == &#39;xyz&#39;:
        _,_,_,_,elements,_ = read_xyz(in_path)
    elif file_type == &#39;pdb&#39;:
        pdbFile = PDBFile(in_path)
        elements = pdbFile.parsePDB()
    return np.asarray(elements)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def main():
    arg_vals = None
    args = get_args(arg_vals)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.print_xyz"><code class="name flex">
<span>def <span class="ident">print_xyz</span></span>(<span>num_atoms, x, y, z, atom_type, title=None, ofi=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_xyz(num_atoms, x, y, z, atom_type, title=None, ofi=None):
    print(num_atoms, file=ofi)
    if title:
        print(title[:-1], file=ofi)
    else:
        print(&#34;&#34;, file=ofi)
    l = &#34;{0:2}    {1:10.6f}    {2:10.6f}    {3:10.6f}&#34;
    for i in range(num_atoms):
        print(l.format(atom_type[i], x[i],y[i], z[i]), file=ofi)
    pass</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.print_xyz_traj"><code class="name flex">
<span>def <span class="ident">print_xyz_traj</span></span>(<span>coords, types, title=None, ofi=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Write an xyz trajectory file to ofi
:param coords: float ndarray with size [f,num_atoms,3] where f is num frames
:param types: elements
:param title: title for each frame
:param ofi: open file handle for writing
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_xyz_traj(coords, types, title=None, ofi=None):
    &#34;&#34;&#34;
    Write an xyz trajectory file to ofi
    :param coords: float ndarray with size [f,num_atoms,3] where f is num frames
    :param types: elements
    :param title: title for each frame
    :param ofi: open file handle for writing
    :return:
    &#34;&#34;&#34;
    num_atoms = coords.shape[1]
    for f in range(coords.shape[0]):
        print_xyz(num_atoms, coords[f,:,0], coords[f,:,1], coords[f,:,2],
                  types, title=title, ofi=ofi)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.rawincount"><code class="name flex">
<span>def <span class="ident">rawincount</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the number of lines in filename
:param filename:
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rawincount(filename):
    &#34;&#34;&#34;
    Get the number of lines in filename
    :param filename:
    :return:
    &#34;&#34;&#34;
    f = open(filename, &#39;rb&#39;)
    bufgen = takewhile(lambda x: x, (f.raw.read(1024*1024) for _ in repeat(None)))
    return sum( buf.count(b&#39;\n&#39;) for buf in bufgen )</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.read_xyz"><code class="name flex">
<span>def <span class="ident">read_xyz</span></span>(<span>ifpath, return_coord_array=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads an xyz file
:param ifpath:
:return: num_atoms, x, y, z, atom_type, title as numpy int or float arrays</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_xyz(ifpath, return_coord_array=False):
    &#34;&#34;&#34;
    Reads an xyz file
    :param ifpath:
    :return: num_atoms, x, y, z, atom_type, title as numpy int or float arrays
    &#34;&#34;&#34;
    with open(ifpath) as ifi:
        try:
            num_atoms = int(ifi.readline())
        except RuntimeError:
            raise RuntimeError(&#34;Error reading n atoms&#34;)

        title = ifi.readline()
        x = np.zeros(num_atoms, dtype=float)
        y = np.zeros(num_atoms, dtype=float)
        z = np.zeros(num_atoms, dtype=float)
        atom_type = [&#39;&#39;] * num_atoms
        for i in range(num_atoms):
            line = ifi.readline()
            words = line.split()
            atom_type[i] = words[0]
            x[i] = float(words[1])
            y[i] = float(words[2])
            z[i] = float(words[3])
            if atom_type[i] == &#39;OH2&#39;:
                atom_type[i] = &#39;O&#39;
            elif atom_type[i] == &#39;H1&#39; or atom_type[i] == &#39;H2&#39;\
                    or atom_type[i] == &#39;H3&#39;:
                atom_type[i] = &#39;H&#39;
    if return_coord_array:
        return num_atoms, np.stack((x,y,z), axis=-1), atom_type, title
    return num_atoms, x, y, z, atom_type, title</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.read_xyz2"><code class="name flex">
<span>def <span class="ident">read_xyz2</span></span>(<span>ifpath)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads an xyz file and returns numpy array and atomic numbers from element
:param ifpath:
:return: num_atoms, coords, atom_type, atom_number as numpy int or float
:rtype: (np.ndarray(n, dtype=int16), np.ndarray(n,3, dtype=float),
np.ndarray(n, dtype="U2"), np.ndarray(n, dtype=int8)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_xyz2(ifpath):
    &#34;&#34;&#34;
    Reads an xyz file and returns numpy array and atomic numbers from element
    :param ifpath:
    :return: num_atoms, coords, atom_type, atom_number as numpy int or float
    :rtype: (np.ndarray(n, dtype=int16), np.ndarray(n,3, dtype=float),
    np.ndarray(n, dtype=&#34;U2&#34;), np.ndarray(n, dtype=int8)
    &#34;&#34;&#34;
    el_dict = {&#39;H&#39;:1, &#39;C&#39;:6, &#39;N&#39;:7, &#39;O&#39;:8}
    num_dict = {1:&#39;H&#39;, 6:&#39;C&#39;, 7:&#39;N&#39;, 8:&#39;O&#39;}
    with open(ifpath) as ifi:
        try:
            num_atoms = np.int16(ifi.readline())
        except:
            sys.exit(&#34;Error reading n atoms&#34;)
        coords = np.zeros((num_atoms,3), dtype=float)
        atom_type = np.zeros(num_atoms, dtype=&#34;U2&#34;)
        atomic_number = np.zeros(num_atoms, dtype=np.int8)
        ifi.readline()
        for i in range(num_atoms):
            line = ifi.readline()
            words = line.split()
            atom_type[i] = words[0]
            coords[i, 0] = float(words[1])
            coords[i, 1] = float(words[2])
            coords[i, 2] = float(words[3])
        if atom_type[i][0].isdigit():
            for i, el in enumerate(atom_type):
                atomic_number[i] = int(atom_type[i])
                atom_type[i] = num_dict[atomic_number[i]]

    return num_atoms, coords, atom_type</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.read_xyz_trajectory"><code class="name flex">
<span>def <span class="ident">read_xyz_trajectory</span></span>(<span>ifpath)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads an xyz file
:param ifpath:
:return: num_atoms, x, y, z, atom_type, title as numpy int or float arrays</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_xyz_trajectory(ifpath):
    &#34;&#34;&#34;
    Reads an xyz file
    :param ifpath:
    :return: num_atoms, x, y, z, atom_type, title as numpy int or float arrays
    &#34;&#34;&#34;
    with open(ifpath) as ifi:
        try:
            num_atoms = int(ifi.readline())
        except RuntimeError:
            raise RuntimeError(&#34;Error reading n atoms&#34;)
        nlines = rawincount(ifpath)
        if nlines % (num_atoms + 2) != 0:
            raise RuntimeError(&#34;Improper number of lines in trajectory&#34;)
        nframes = nlines//(num_atoms+2)

        title = ifi.readline()
        coords = np.zeros((nframes, num_atoms, 3), dtype=float)
        atom_type = [&#39;&#39;] * num_atoms
        ifi.seek(0)
        for f in range(nframes):
            line = ifi.readline()
            line = ifi.readline()
            for i in range(num_atoms):
                line = ifi.readline()
                words = line.split()
                try:
                    atom_type[i] = words[0]
                    coords[f, i, 0] = float(words[1])
                    coords[f, i, 1] = float(words[2])
                    coords[f, i, 2] = float(words[3])
                except:
                    print(&#34;Error reading xyz trajectory at frame %d&#34; % f)
                    print(&#34;Current line:&#34;)
                    print(line)
                    sys.exit()
                if atom_type[i] == &#39;OH2&#39;:
                    atom_type[i] = &#39;O&#39;
                elif atom_type[i] == &#39;H1&#39; or atom_type[i] == &#39;H2&#39;\
                        or atom_type[i] == &#39;H3&#39;:
                    atom_type[i] = &#39;H&#39;
    return num_atoms, coords, atom_type, title</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.testGroups"><code class="name flex">
<span>def <span class="ident">testGroups</span></span>(<span>groupsPath='./test_files/groups.log')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def testGroups(groupsPath=&#39;./test_files/groups.log&#39;):
    gFile = GroupsFile(groupsPath)
    groups = gFile.getGroups()
    groups.printGroups()</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.testPSFBonds"><code class="name flex">
<span>def <span class="ident">testPSFBonds</span></span>(<span>psfPath='./test_files/h3o.psf')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def testPSFBonds(psfPath=&#39;./test_files/h3o.psf&#39;):
    psf = PSFFile(psfPath)
    bonds = psf.getBonds()
    bonds.printBonds(style=&#39;psf&#39;)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.wrap_coords"><code class="name flex">
<span>def <span class="ident">wrap_coords</span></span>(<span>cell_x, cell_y, cell_z, x, y, z, num_atoms, center)</span>
</code></dt>
<dd>
<section class="desc"><ol>
<li>Translate all atoms by vector from atom designated by center
to center of box defined by [[0, cell_x],[0, cell_y], [0, cell_z]]</li>
<li>wrap all atoms outside of the above box into the box</li>
</ol>
<p>:param cell_x: x cell dimention float
:param cell_y: y cell dimention float
:param cell_z: float z cell dimension
:param x: np float array x coords
:param y: np float array y coords
:param z: np float array z coords
:param num_atoms: int
:param center: int 0-based index of atom center
:return: x, y, z</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wrap_coords(cell_x, cell_y, cell_z, x, y, z, num_atoms, center):
    &#34;&#34;&#34;
    1. Translate all atoms by vector from atom designated by center
    to center of box defined by [[0, cell_x],[0, cell_y], [0, cell_z]]
    2. wrap all atoms outside of the above box into the box

    :param cell_x: x cell dimention float
    :param cell_y: y cell dimention float
    :param cell_z: float z cell dimension
    :param x: np float array x coords
    :param y: np float array y coords
    :param z: np float array z coords
    :param num_atoms: int
    :param center: int 0-based index of atom center
    :return: x, y, z
    &#34;&#34;&#34;
    def wrap_dimension(x, cell_x):
        no_wraps = False
        while not no_wraps:
            no_wraps = True
            for i in range(x.size):
                if x[i] &lt; 0:
                    x[i] += cell_x
                    no_wraps = False
                elif x[i] &gt; cell_x:
                    x[i] -= cell_x
                    no_wraps = False
        return x



    # Find the translation vector to shift all atoms by the vector
    # from the desired centers coords to the new center
    center_a_coords = np.asarray([x[center], y[center], z[center]])
    new_center = np.asarray([cell_x/2., cell_y/2., cell_z/2.])
    translation = new_center - center_a_coords

    x[:] += translation[0]
    y[:] += translation[1]
    z[:] += translation[2]


    # Now wrap the atoms
    x = wrap_dimension(x, cell_x)
    y = wrap_dimension(y, cell_y)
    z = wrap_dimension(z, cell_z)
    return x, y, z</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="adaptive_md_tools.mdtools.Bonds"><code class="flex name class">
<span>class <span class="ident">Bonds</span></span>
<span>(</span><span>numAtoms, bond_list=[])</span>
</code></dt>
<dd>
<section class="desc"><p>A class to keep track of the bonding for system</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Bonds:
    &#34;&#34;&#34;
    A class to keep track of the bonding for system
    &#34;&#34;&#34;
    def __init__(self, numAtoms, bond_list=[]):
        self.numAtoms = numAtoms
        self.bonds = [[] for x in range(numAtoms)]
        self.numBonds = 0
        self.blist = []

        for b in bond_list:
            self.addBonds(b[0], b[1])
        return

    def addBonds(self, a1, a2):
        &#34;&#34;&#34;
        Add a bond to a1 and a2. This means a1 is added to a2&#39;s bonds and
        a2 is added to a1&#39;s bonds
        :param a1:
        :param a2:
        :return:
        &#34;&#34;&#34;
        if a2 in self.bonds[a1]:
            print(&#34;Cannot add bond, atom %d is already bonded to atom %d&#34;
                  % (a1, a2))
            raise RuntimeError

        if a1 in self.bonds[a2]:
            print(&#34;Cannot add bond, atom %d is already bonded to atom %d&#34;
                  % (a2, a1))
            raise RuntimeError

        if a1 == a2:
            print(&#34;Cannot bond atom to itself&#34;)
            raise RuntimeError
        self.bonds[a1].append(a2)
        self.bonds[a2].append(a1)
        self.numBonds += 1
        self.blist.append((a1,a2))
        return

    def printBonds(self, style=None):
        pBonds = self.getUniqueBonds()
        nBonds = len(pBonds)
        bLine = &#34;{0:9d}   {1:9d}&#34;
        psfLine = &#34;{0:8d}{1:8d}{2:8d}{3:8d}{4:8d}{5:8d}{6:8d}{7:8d}&#34;
        partLine = &#34;{0:8d}{1:8d}&#34;
        if not style:
            print(&#34;NBonds: &#34; + str(nBonds))
            for i in range(nBonds):
                print(bLine.format(*pBonds[i]))
        if style == &#39;psf&#39;:
            tBonds = []
            for i in pBonds:
                tBonds.append((i[0]+1, i[1]+1))
            pBonds = tBonds
            print(&#34;{0:8d} !NBONDS: bonds&#34;.format(nBonds))
            nLines = nBonds // 4
            b = 0
            for i in range(nLines):
                print(psfLine.format(*pBonds[b], *pBonds[b+1], *pBonds[b+2],
                                     *pBonds[b+3]))
                b += 4
            if nBonds % 4 &gt; 0:
                lastLine = &#34;&#34;
                for i in range(nBonds % 4):
                    lastLine += partLine.format(*pBonds[b])
                    b += 1
                print(lastLine)
        return

    def getUniqueBonds(self):
        uniqueBonds = []
        for i in range(self.numAtoms - 1):
            for j in self.bonds[i]:
                if j &gt; i:
                    uniqueBonds.append((i, j))
        return uniqueBonds</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="adaptive_md_tools.mdtools.Bonds.addBonds"><code class="name flex">
<span>def <span class="ident">addBonds</span></span>(<span>self, a1, a2)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a bond to a1 and a2. This means a1 is added to a2's bonds and
a2 is added to a1's bonds
:param a1:
:param a2:
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addBonds(self, a1, a2):
    &#34;&#34;&#34;
    Add a bond to a1 and a2. This means a1 is added to a2&#39;s bonds and
    a2 is added to a1&#39;s bonds
    :param a1:
    :param a2:
    :return:
    &#34;&#34;&#34;
    if a2 in self.bonds[a1]:
        print(&#34;Cannot add bond, atom %d is already bonded to atom %d&#34;
              % (a1, a2))
        raise RuntimeError

    if a1 in self.bonds[a2]:
        print(&#34;Cannot add bond, atom %d is already bonded to atom %d&#34;
              % (a2, a1))
        raise RuntimeError

    if a1 == a2:
        print(&#34;Cannot bond atom to itself&#34;)
        raise RuntimeError
    self.bonds[a1].append(a2)
    self.bonds[a2].append(a1)
    self.numBonds += 1
    self.blist.append((a1,a2))
    return</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Bonds.getUniqueBonds"><code class="name flex">
<span>def <span class="ident">getUniqueBonds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getUniqueBonds(self):
    uniqueBonds = []
    for i in range(self.numAtoms - 1):
        for j in self.bonds[i]:
            if j &gt; i:
                uniqueBonds.append((i, j))
    return uniqueBonds</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Bonds.printBonds"><code class="name flex">
<span>def <span class="ident">printBonds</span></span>(<span>self, style=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def printBonds(self, style=None):
    pBonds = self.getUniqueBonds()
    nBonds = len(pBonds)
    bLine = &#34;{0:9d}   {1:9d}&#34;
    psfLine = &#34;{0:8d}{1:8d}{2:8d}{3:8d}{4:8d}{5:8d}{6:8d}{7:8d}&#34;
    partLine = &#34;{0:8d}{1:8d}&#34;
    if not style:
        print(&#34;NBonds: &#34; + str(nBonds))
        for i in range(nBonds):
            print(bLine.format(*pBonds[i]))
    if style == &#39;psf&#39;:
        tBonds = []
        for i in pBonds:
            tBonds.append((i[0]+1, i[1]+1))
        pBonds = tBonds
        print(&#34;{0:8d} !NBONDS: bonds&#34;.format(nBonds))
        nLines = nBonds // 4
        b = 0
        for i in range(nLines):
            print(psfLine.format(*pBonds[b], *pBonds[b+1], *pBonds[b+2],
                                 *pBonds[b+3]))
            b += 4
        if nBonds % 4 &gt; 0:
            lastLine = &#34;&#34;
            for i in range(nBonds % 4):
                lastLine += partLine.format(*pBonds[b])
                b += 1
            print(lastLine)
    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="adaptive_md_tools.mdtools.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>filePath, fileType='')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class File:
    def __init__(self, filePath, fileType=&#39;&#39;):
        try:
            self.ifi = open(filePath, &#39;r&#39;)
            self.path = filePath
        except FileNotFoundError:
            print(&#34;Cannot open {0} file: &#34;.format(fileType) + filePath)
            sys.exit()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="adaptive_md_tools.mdtools.Mol2File" href="#adaptive_md_tools.mdtools.Mol2File">Mol2File</a></li>
<li><a title="adaptive_md_tools.mdtools.PDBFile" href="#adaptive_md_tools.mdtools.PDBFile">PDBFile</a></li>
</ul>
</dd>
<dt id="adaptive_md_tools.mdtools.Groups"><code class="flex name class">
<span>class <span class="ident">Groups</span></span>
<span>(</span><span>numGroups, numAtoms)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to keep track of the AP group stuff</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Groups:
    &#34;&#34;&#34;
    A class to keep track of the AP group stuff
    &#34;&#34;&#34;
    def __init__(self, numGroups, numAtoms):
        self.numAtoms = numAtoms
        self.numGroups = numGroups
        self.atomGroups = np.full(numAtoms, -1, dtype=int)
        self.groupAtoms = [[] for x in range(numGroups)]
        self.groupReps = np.full(numGroups, -1, dtype=int)
        self.nonDefaultRepresentative = False

    def setAtomGroup(self, ind, group):
        &#34;&#34;&#34;
        Affiliate the atom with a group. If this is the first atom
        affiliated with the group, make it the group representative.
        :param ind: the atom index
        :param group: the group to affiliate atom with
        :return:
        &#34;&#34;&#34;
        if ind &gt; self.numAtoms - 1:
            print(&#34;Error, atom index out of range for setting group&#34;)
            raise IndexError
        if group &gt; self.numGroups - 1:
            print(&#34;Error, group index out of range for setting group&#34;)
        self.atomGroups[ind] = group
        if ind not in self.groupAtoms[group]:
            self.groupAtoms[group].append(ind)
            self.groupReps[group] = self.groupAtoms[group][0]
        else:
            print(&#34;Error, atom %d already in group %d&#34; % (ind, group))
            raise RuntimeError

        return

    def setGroupRep(self, ind, group):
        &#34;&#34;&#34;
        Set the group representative
        :param ind: atom index to make representative
        :param group: group to make representative of
        :return:
        &#34;&#34;&#34;
        if ind in self.groupAtoms[group]:
            self.groupAtoms[group].insert(0, self.groupAtoms[group].pop(
                self.groupAtoms[group].index(ind)))
            self.groupReps[group] = self.groupAtoms[group][0]
        else:
            &#34;Atom %d cannot be group representative because it is not in the&#34;
            &#34; group!&#34;
            raise RuntimeError
        return

    def checkGroups(self):
        &#34;&#34;&#34;
        Check to ensure all atoms are assigned to group and all groups have
        a representative atom. Return false if this is not the case
        :return: goodCheck = logical
        &#34;&#34;&#34;
        goodCheck = True
        # Check that groups all have a representative
        for i in range(self.numGroups):
            if not self.groupAtoms[i]:
                print(&#34;Group %d no atoms&#34; % i)
                goodCheck = False

        # Check that all atoms are assigned to group
        for i in range(self.numAtoms):
            if self.atomGroups[i] &lt; 0:
                print(&#34;Atom %d not assigned to group&#34; % i)
                goodCheck = False
        return goodCheck

    def printGroups(self, style=&#39;groups.log&#39;):
        header = &#39;# NGroups       NAtoms&#39;
        header2 = &#39;# Group       AtomIndex (both 1 based)&#39;
        outLine = &#39;{0:9d}    {1:9d}&#39;
        if style == &#39;groups.log&#39;:
            print(header)
            print(outLine.format(self.numGroups, self.numAtoms))
            print(header2)
            for i in range(self.numGroups):
                for j in range(len(self.groupAtoms[i])):
                    print(outLine.format(i + 1, self.groupAtoms[i][j] + 1))
            print(&#39;END&#39;)

    def transferAtom(self, atom, new_atom):
        &#34;&#34;&#34;
        Change the group of an atom specified by ATOM to the group of the atom
        specified by NEW_BOND
        :param atom:
        :param new_atom:
        :return:
        &#34;&#34;&#34;
        old_group = self.atomGroups[atom]
        new_group = self.atomGroups[new_atom]
        self.groupAtoms[old_group].remove(atom)
        self.groupAtoms[new_group].append(atom)
        self.atomGroups[atom] = new_group
        return</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="adaptive_md_tools.mdtools.Groups.checkGroups"><code class="name flex">
<span>def <span class="ident">checkGroups</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check to ensure all atoms are assigned to group and all groups have
a representative atom. Return false if this is not the case
:return: goodCheck = logical</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def checkGroups(self):
    &#34;&#34;&#34;
    Check to ensure all atoms are assigned to group and all groups have
    a representative atom. Return false if this is not the case
    :return: goodCheck = logical
    &#34;&#34;&#34;
    goodCheck = True
    # Check that groups all have a representative
    for i in range(self.numGroups):
        if not self.groupAtoms[i]:
            print(&#34;Group %d no atoms&#34; % i)
            goodCheck = False

    # Check that all atoms are assigned to group
    for i in range(self.numAtoms):
        if self.atomGroups[i] &lt; 0:
            print(&#34;Atom %d not assigned to group&#34; % i)
            goodCheck = False
    return goodCheck</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Groups.printGroups"><code class="name flex">
<span>def <span class="ident">printGroups</span></span>(<span>self, style='groups.log')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def printGroups(self, style=&#39;groups.log&#39;):
    header = &#39;# NGroups       NAtoms&#39;
    header2 = &#39;# Group       AtomIndex (both 1 based)&#39;
    outLine = &#39;{0:9d}    {1:9d}&#39;
    if style == &#39;groups.log&#39;:
        print(header)
        print(outLine.format(self.numGroups, self.numAtoms))
        print(header2)
        for i in range(self.numGroups):
            for j in range(len(self.groupAtoms[i])):
                print(outLine.format(i + 1, self.groupAtoms[i][j] + 1))
        print(&#39;END&#39;)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Groups.setAtomGroup"><code class="name flex">
<span>def <span class="ident">setAtomGroup</span></span>(<span>self, ind, group)</span>
</code></dt>
<dd>
<section class="desc"><p>Affiliate the atom with a group. If this is the first atom
affiliated with the group, make it the group representative.
:param ind: the atom index
:param group: the group to affiliate atom with
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setAtomGroup(self, ind, group):
    &#34;&#34;&#34;
    Affiliate the atom with a group. If this is the first atom
    affiliated with the group, make it the group representative.
    :param ind: the atom index
    :param group: the group to affiliate atom with
    :return:
    &#34;&#34;&#34;
    if ind &gt; self.numAtoms - 1:
        print(&#34;Error, atom index out of range for setting group&#34;)
        raise IndexError
    if group &gt; self.numGroups - 1:
        print(&#34;Error, group index out of range for setting group&#34;)
    self.atomGroups[ind] = group
    if ind not in self.groupAtoms[group]:
        self.groupAtoms[group].append(ind)
        self.groupReps[group] = self.groupAtoms[group][0]
    else:
        print(&#34;Error, atom %d already in group %d&#34; % (ind, group))
        raise RuntimeError

    return</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Groups.setGroupRep"><code class="name flex">
<span>def <span class="ident">setGroupRep</span></span>(<span>self, ind, group)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the group representative
:param ind: atom index to make representative
:param group: group to make representative of
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setGroupRep(self, ind, group):
    &#34;&#34;&#34;
    Set the group representative
    :param ind: atom index to make representative
    :param group: group to make representative of
    :return:
    &#34;&#34;&#34;
    if ind in self.groupAtoms[group]:
        self.groupAtoms[group].insert(0, self.groupAtoms[group].pop(
            self.groupAtoms[group].index(ind)))
        self.groupReps[group] = self.groupAtoms[group][0]
    else:
        &#34;Atom %d cannot be group representative because it is not in the&#34;
        &#34; group!&#34;
        raise RuntimeError
    return</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Groups.transferAtom"><code class="name flex">
<span>def <span class="ident">transferAtom</span></span>(<span>self, atom, new_atom)</span>
</code></dt>
<dd>
<section class="desc"><p>Change the group of an atom specified by ATOM to the group of the atom
specified by NEW_BOND
:param atom:
:param new_atom:
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def transferAtom(self, atom, new_atom):
    &#34;&#34;&#34;
    Change the group of an atom specified by ATOM to the group of the atom
    specified by NEW_BOND
    :param atom:
    :param new_atom:
    :return:
    &#34;&#34;&#34;
    old_group = self.atomGroups[atom]
    new_group = self.atomGroups[new_atom]
    self.groupAtoms[old_group].remove(atom)
    self.groupAtoms[new_group].append(atom)
    self.atomGroups[atom] = new_group
    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="adaptive_md_tools.mdtools.GroupsFile"><code class="flex name class">
<span>class <span class="ident">GroupsFile</span></span>
<span>(</span><span>groupsPath)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class GroupsFile:
    def __init__(self, groupsPath):
        try:
            self.ifi = open(groupsPath, &#39;r&#39;)
            self.groupsPath = groupsPath
        except FileNotFoundError:
            print(&#34;Cannot find groups file: &#34; + groupsPath)
            sys.exit()

    def getGroups(self):

        # Read the number of groups, then number of atoms from the groups file
        try:
            line = _rLine(self.ifi)
            numGroups, numAtoms = [int(i) for i in line.split()[:2]]
        except IOError:
            print(&#34;Error reading number of groups and atoms from groups file: &#34;
                  + self.groupsPath)
            sys.exit()

        # Initialize the groups structure
        groups = Groups(numGroups, numAtoms)

        # Fill up the groups
        while True:
            line = _rLine(self.ifi)
            if not line:
                print(&#39;Error reading groups file, &#34;END&#34; not encountered&#39;)
                raise IOError
            words = line.split()
            if words[0].upper() == &#39;END&#39;:
                break

            group = int(words[0]) - 1
            ind = int(words[1]) - 1
            groups.setAtomGroup(ind, group)

        # Exit if there is anything left over
        if not groups.checkGroups():
            print(&#34;Error, not all groups or atoms were in groups file&#34;)
            raise RuntimeError

        return groups</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="adaptive_md_tools.mdtools.GroupsFile.getGroups"><code class="name flex">
<span>def <span class="ident">getGroups</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getGroups(self):

    # Read the number of groups, then number of atoms from the groups file
    try:
        line = _rLine(self.ifi)
        numGroups, numAtoms = [int(i) for i in line.split()[:2]]
    except IOError:
        print(&#34;Error reading number of groups and atoms from groups file: &#34;
              + self.groupsPath)
        sys.exit()

    # Initialize the groups structure
    groups = Groups(numGroups, numAtoms)

    # Fill up the groups
    while True:
        line = _rLine(self.ifi)
        if not line:
            print(&#39;Error reading groups file, &#34;END&#34; not encountered&#39;)
            raise IOError
        words = line.split()
        if words[0].upper() == &#39;END&#39;:
            break

        group = int(words[0]) - 1
        ind = int(words[1]) - 1
        groups.setAtomGroup(ind, group)

    # Exit if there is anything left over
    if not groups.checkGroups():
        print(&#34;Error, not all groups or atoms were in groups file&#34;)
        raise RuntimeError

    return groups</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="adaptive_md_tools.mdtools.MMTypes"><code class="flex name class">
<span>class <span class="ident">MMTypes</span></span>
<span>(</span><span>numAtoms)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class MMTypes:
    def __init__(self, numAtoms):
        self.numAtoms = numAtoms
        self.strWidth = 4
        sid = &#34;U%d&#34; % self.strWidth
        self.segName = np.zeros(numAtoms, dtype=sid)
        self.resId = np.zeros(numAtoms, dtype=int)
        self.resName = np.zeros(numAtoms, dtype=sid)
        self.charge = np.zeros(numAtoms, dtype=float)
        self.atomName = np.zeros(numAtoms, dtype=sid)
        self.atomType = np.zeros(numAtoms, dtype=sid)
        self.atomMass = np.zeros(numAtoms, dtype=float)
        self.element = np.zeros(numAtoms, dtype=&#39;U2&#39;)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Mol2File"><code class="flex name class">
<span>class <span class="ident">Mol2File</span></span>
<span>(</span><span>filePath, fileType='')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Mol2File(File):
    def getTopo(self):
        topo = Topology()
        topo.mm_types = self.getMMTypes()
        topo.num_atoms = topo.mm_types.numAtoms
        topo.bonds = self.getBonds()
        return topo

    def getNumAtoms(self):
        self.ifi.seek(0)
        while True:
            line = self.ifi.readline()
            words = line.split()
            if &#39;MOLECULE&#39; in line:
                line = self.ifi.readline()
                words = self.ifi.readline().split()
                return int(words[0]), int(words[1])
        print(&#34;Could not find number of atoms&#34;)
        raise ValueError

    def getMMTypes(self):
        numAtoms, numBonds = self.getNumAtoms()
        mmNames = MMTypes(numAtoms)
        self.ifi.seek(0)
        found_atoms = False
        while True:
            line = self.ifi.readline()
            if not line:
                break
            if &#39;ATOM&#39; in line.upper() and not found_atoms:
                self.read_atom(mmNames)
                found_atoms = True
        if not found_atoms:
            print(&#34;Error, could not find ATOM section&#34;)
            raise LookupError
        return mmNames


    def getBonds(self):
        numAtoms, numBonds = self.getNumAtoms()
        bonds = Bonds(numAtoms)
        self.ifi.seek(0)
        found_bonds = False
        while True:
            line = self.ifi.readline()
            if not line:
                break
            if &#39;BOND&#39; in line.upper() and not found_bonds:
                self.read_bonds(bonds, numBonds)
                found_bonds = True
        if not found_bonds:
            print(&#34;Error, could not find bonds&#34;)
            raise LookupError
        return bonds

    def read_atom(self, mmType):
        for i in range(mmType.numAtoms):
            line = self.ifi.readline()
            words = line.split()
            mmType.element[i] = words[1]
            mmType.atomType[i] = words[5]
            mmType.atomName[i] = words[7]
            mmType.charge[i] = float(words[8])

    def read_bonds(self, bonds, numBonds):
        for i in range(numBonds):
            line = self.ifi.readline()
            words = line.split()
            bonds.addBonds(int(words[1])-1, int(words[2])-1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="adaptive_md_tools.mdtools.File" href="#adaptive_md_tools.mdtools.File">File</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="adaptive_md_tools.mdtools.Mol2File.getBonds"><code class="name flex">
<span>def <span class="ident">getBonds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getBonds(self):
    numAtoms, numBonds = self.getNumAtoms()
    bonds = Bonds(numAtoms)
    self.ifi.seek(0)
    found_bonds = False
    while True:
        line = self.ifi.readline()
        if not line:
            break
        if &#39;BOND&#39; in line.upper() and not found_bonds:
            self.read_bonds(bonds, numBonds)
            found_bonds = True
    if not found_bonds:
        print(&#34;Error, could not find bonds&#34;)
        raise LookupError
    return bonds</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Mol2File.getMMTypes"><code class="name flex">
<span>def <span class="ident">getMMTypes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getMMTypes(self):
    numAtoms, numBonds = self.getNumAtoms()
    mmNames = MMTypes(numAtoms)
    self.ifi.seek(0)
    found_atoms = False
    while True:
        line = self.ifi.readline()
        if not line:
            break
        if &#39;ATOM&#39; in line.upper() and not found_atoms:
            self.read_atom(mmNames)
            found_atoms = True
    if not found_atoms:
        print(&#34;Error, could not find ATOM section&#34;)
        raise LookupError
    return mmNames</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Mol2File.getNumAtoms"><code class="name flex">
<span>def <span class="ident">getNumAtoms</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getNumAtoms(self):
    self.ifi.seek(0)
    while True:
        line = self.ifi.readline()
        words = line.split()
        if &#39;MOLECULE&#39; in line:
            line = self.ifi.readline()
            words = self.ifi.readline().split()
            return int(words[0]), int(words[1])
    print(&#34;Could not find number of atoms&#34;)
    raise ValueError</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Mol2File.getTopo"><code class="name flex">
<span>def <span class="ident">getTopo</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getTopo(self):
    topo = Topology()
    topo.mm_types = self.getMMTypes()
    topo.num_atoms = topo.mm_types.numAtoms
    topo.bonds = self.getBonds()
    return topo</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Mol2File.read_atom"><code class="name flex">
<span>def <span class="ident">read_atom</span></span>(<span>self, mmType)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_atom(self, mmType):
    for i in range(mmType.numAtoms):
        line = self.ifi.readline()
        words = line.split()
        mmType.element[i] = words[1]
        mmType.atomType[i] = words[5]
        mmType.atomName[i] = words[7]
        mmType.charge[i] = float(words[8])</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Mol2File.read_bonds"><code class="name flex">
<span>def <span class="ident">read_bonds</span></span>(<span>self, bonds, numBonds)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_bonds(self, bonds, numBonds):
    for i in range(numBonds):
        line = self.ifi.readline()
        words = line.split()
        bonds.addBonds(int(words[1])-1, int(words[2])-1)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="adaptive_md_tools.mdtools.PDBFile"><code class="flex name class">
<span>class <span class="ident">PDBFile</span></span>
<span>(</span><span>pdbPath, required=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class PDBFile(File):
    def __init__(self, pdbPath, required=None):
        File.__init__(self, pdbPath, &#39;pdb&#39;)
        self.required = required  # required fields to parse
        self.numAtoms = 0

    def parsePDB(self):
        serial = []
        name = []
        altLoc = []
        resName = []
        chainID = []
        resSeq = []
        iCode = []
        x = []
        y = []
        z = []
        occupancy, tempFactor, element, charge = [], [], [], []

        while True:
            line = self.ifi.readline()
            if not line:
                break
            if len(line) &lt; 6: continue
            if (&#39;ATOM&#39; in line[:6].upper()) or (&#39;HETATM&#39; in line[:6].upper()):
                break
        while line.lstrip()[:3].upper() != &#39;END&#39;:
            try:
                serial.append(int(line[6:11]))
            except:
                pass
            try:
                name.append(line[12:16])
            except:
                pass
            try:
                altLoc.append(line[16])
            except:
                pass
            try:
                resName.append(line[17:20])
            except:
                pass
            try:
                chainID.append(line[21])
            except:
                pass
            try:
                resSeq.append(line[22:26])
            except:
                pass
            try:
                iCode.append(line[26])
            except:
                pass
            try:
                x.append(float(line[30:38]))
            except:
                pass
            try:
                y.append(float(line[38:46]))
            except:
                pass
            try:
                z.append(float[line[46:54]])
            except:
                pass
            try:
                occupancy.append(float(line[54:60]))
            except:
                pass
            try:
                tempFactor.append(float(line[60:66]))
            except:
                pass
            try:
                element.append(line[76:78].strip())
            except:
                if &#39;element&#39; in self.required:
                    print(&#34;Error, could not parse element from pdb &#34;+ self.path)
                    sys.exit()
            try:
                charge.append(line[78:80])
            except:
                pass

            self.numAtoms += 1
            line = self.ifi.readline()

        element = np.asarray(element)
        return element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="adaptive_md_tools.mdtools.File" href="#adaptive_md_tools.mdtools.File">File</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="adaptive_md_tools.mdtools.PDBFile.parsePDB"><code class="name flex">
<span>def <span class="ident">parsePDB</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def parsePDB(self):
    serial = []
    name = []
    altLoc = []
    resName = []
    chainID = []
    resSeq = []
    iCode = []
    x = []
    y = []
    z = []
    occupancy, tempFactor, element, charge = [], [], [], []

    while True:
        line = self.ifi.readline()
        if not line:
            break
        if len(line) &lt; 6: continue
        if (&#39;ATOM&#39; in line[:6].upper()) or (&#39;HETATM&#39; in line[:6].upper()):
            break
    while line.lstrip()[:3].upper() != &#39;END&#39;:
        try:
            serial.append(int(line[6:11]))
        except:
            pass
        try:
            name.append(line[12:16])
        except:
            pass
        try:
            altLoc.append(line[16])
        except:
            pass
        try:
            resName.append(line[17:20])
        except:
            pass
        try:
            chainID.append(line[21])
        except:
            pass
        try:
            resSeq.append(line[22:26])
        except:
            pass
        try:
            iCode.append(line[26])
        except:
            pass
        try:
            x.append(float(line[30:38]))
        except:
            pass
        try:
            y.append(float(line[38:46]))
        except:
            pass
        try:
            z.append(float[line[46:54]])
        except:
            pass
        try:
            occupancy.append(float(line[54:60]))
        except:
            pass
        try:
            tempFactor.append(float(line[60:66]))
        except:
            pass
        try:
            element.append(line[76:78].strip())
        except:
            if &#39;element&#39; in self.required:
                print(&#34;Error, could not parse element from pdb &#34;+ self.path)
                sys.exit()
        try:
            charge.append(line[78:80])
        except:
            pass

        self.numAtoms += 1
        line = self.ifi.readline()

    element = np.asarray(element)
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="adaptive_md_tools.mdtools.PSFFile"><code class="flex name class">
<span>class <span class="ident">PSFFile</span></span>
<span>(</span><span>psfPath)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class PSFFile:
    def __init__(self, psfPath):
        try:
            self.ifi = open(psfPath, &#39;r&#39;)
        except FileNotFoundError:
            print(&#34;Cannot find psf file: &#34; + psfPath)
            sys.exit()

    def getNumAtoms(self):
        &#34;&#34;&#34;
        Read the number of atoms from the PSF file
        This leave the file at the NATOM line! Rewind it if you need to
        go from beginning and don&#39;t change because other programs depend
        on it!
        :return:
        &#34;&#34;&#34;
        self.ifi.seek(0)
        natoms = 0
        while True:
            line = self.ifi.readline()
            if not line:
                break
            if &#34;!NATOM&#34; in line:
                try:
                    natoms = int(line.split()[0])
                    break
                except IOError:
                    print(&#34;Cannot read natoms from psf file&#34;)
                    sys.exit()
        if natoms == 0:
            print(&#34;Could not find NATOM in psf file&#34;)
            raise IOError

        return natoms

    def getTopo(self):
        topo = Topology()
        topo.mm_types = self.getMMTypes()
        topo.num_atoms = topo.mm_types.numAtoms
        return topo


    def getBonds(self):
        numAtoms = self.getNumAtoms()
        bonds = Bonds(numAtoms)
        self.ifi.seek(0)
        foundNBond = False
        while True:
            line = self.ifi.readline()
            if not line:
                break
            if &#34;!NBOND&#34; in line:
                foundNBond = True
                break

        if not foundNBond:
            print(&#34;Could not find NBonds section in psf file&#34;)
            raise IOError

        try:
            nbonds = int(line.split()[0])
        except IOError:
            print(&#34;Cannot read Nbonds&#34;)
            sys.exit()

        bondLines = nbonds // 4
        if nbonds % 4 &gt; 0:
            bondLines += 1

        foundBonds = 0

        for l in range(bondLines):
            line = self.ifi.readline()
            words = line.split()
            nwords = len(words)
            nowBonds = nwords // 2
            for i in range(nowBonds):
                a1 = int(words[i * 2]) - 1
                a2 = int(words[i * 2 + 1]) - 1
                bonds.addBonds(a1, a2)
                foundBonds += 1

        if foundBonds != nbonds:
            print(&#34;Did not find all of the bonds!&#34;)
            raise RuntimeError

        return bonds

    def read_beginning_lines(self):
            lines = []
            self.ifi.seek(0)
            line = &#34;&#34;
            found = False
            while found == False:
                line = self.ifi.readline()
                if &#34;!NBOND&#34; not in line:
                    lines.append(line)
                else:
                    found = True
            if not found:
                print(&#34;Error parsing PSF file for lines&#34;)
            return lines


    def getMMTypes(self):
        numAtoms = self.getNumAtoms()
        mmNames = MMTypes(numAtoms)
        for i in range(numAtoms):
            try:
                line = self.ifi.readline()
                words = line.split()
            except IOError:
                print(&#34;Error reading line %d in psf file&#34; % i)
                sys.exit(&#39;mmtypes 1&#39;)

            if len(words) != 9:
                print(&#34;Error, not enough data in psf file for atom %d &#34; % i)
                sys.exit(&#39;mmtypes 2&#39;)

            try:
                mmNames.segName[i] = words[1]
            except IOError:
                print(&#34;Error reading segname&#34;)
                sys.exit(&#39;mmtypes 3&#39;)
            try:
                mmNames.resId[i] = int(words[2])
            except IOError:
                print(&#34;Error reading residue index&#34;)
                sys.exit(&#39;mmtypes 4&#39;)
            try:
                mmNames.resName[i] = words[3]
            except IOError:
                print(&#34;Error reading resdue name&#34;)
                sys.exit(&#39;mmtypes 5&#39;)
            try:
                mmNames.atomName[i] = words[4]
            except IOError:
                print(&#34;Error reading atom name&#34;)
                sys.exit(&#39;mmtypes 6&#39;)
            try:
                mmNames.atomType[i] = words[5]
            except IOError:
                print(&#34;Error reading atom type&#34;)
                sys.exit(&#39;mmtypes 7&#39;)
            try:
                mmNames.charge[i] = float(words[6])
            except IOError:
                print(&#34;Error reading charge&#34;)
                sys.exit(&#39;mmtypes 8&#39;)
            try:
                mmNames.atomMass[i] = float(words[7])
            except IOError:
                print(&#34;Error reading atom mass&#34;)
                sys.exit(&#39;mmtypes 9&#39;)

            except IOError:
                print(&#34;Error reading psf at atom %d&#34; % i)
                sys.exit()
        return mmNames</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="adaptive_md_tools.mdtools.PSFFile.getBonds"><code class="name flex">
<span>def <span class="ident">getBonds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getBonds(self):
    numAtoms = self.getNumAtoms()
    bonds = Bonds(numAtoms)
    self.ifi.seek(0)
    foundNBond = False
    while True:
        line = self.ifi.readline()
        if not line:
            break
        if &#34;!NBOND&#34; in line:
            foundNBond = True
            break

    if not foundNBond:
        print(&#34;Could not find NBonds section in psf file&#34;)
        raise IOError

    try:
        nbonds = int(line.split()[0])
    except IOError:
        print(&#34;Cannot read Nbonds&#34;)
        sys.exit()

    bondLines = nbonds // 4
    if nbonds % 4 &gt; 0:
        bondLines += 1

    foundBonds = 0

    for l in range(bondLines):
        line = self.ifi.readline()
        words = line.split()
        nwords = len(words)
        nowBonds = nwords // 2
        for i in range(nowBonds):
            a1 = int(words[i * 2]) - 1
            a2 = int(words[i * 2 + 1]) - 1
            bonds.addBonds(a1, a2)
            foundBonds += 1

    if foundBonds != nbonds:
        print(&#34;Did not find all of the bonds!&#34;)
        raise RuntimeError

    return bonds</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.PSFFile.getMMTypes"><code class="name flex">
<span>def <span class="ident">getMMTypes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getMMTypes(self):
    numAtoms = self.getNumAtoms()
    mmNames = MMTypes(numAtoms)
    for i in range(numAtoms):
        try:
            line = self.ifi.readline()
            words = line.split()
        except IOError:
            print(&#34;Error reading line %d in psf file&#34; % i)
            sys.exit(&#39;mmtypes 1&#39;)

        if len(words) != 9:
            print(&#34;Error, not enough data in psf file for atom %d &#34; % i)
            sys.exit(&#39;mmtypes 2&#39;)

        try:
            mmNames.segName[i] = words[1]
        except IOError:
            print(&#34;Error reading segname&#34;)
            sys.exit(&#39;mmtypes 3&#39;)
        try:
            mmNames.resId[i] = int(words[2])
        except IOError:
            print(&#34;Error reading residue index&#34;)
            sys.exit(&#39;mmtypes 4&#39;)
        try:
            mmNames.resName[i] = words[3]
        except IOError:
            print(&#34;Error reading resdue name&#34;)
            sys.exit(&#39;mmtypes 5&#39;)
        try:
            mmNames.atomName[i] = words[4]
        except IOError:
            print(&#34;Error reading atom name&#34;)
            sys.exit(&#39;mmtypes 6&#39;)
        try:
            mmNames.atomType[i] = words[5]
        except IOError:
            print(&#34;Error reading atom type&#34;)
            sys.exit(&#39;mmtypes 7&#39;)
        try:
            mmNames.charge[i] = float(words[6])
        except IOError:
            print(&#34;Error reading charge&#34;)
            sys.exit(&#39;mmtypes 8&#39;)
        try:
            mmNames.atomMass[i] = float(words[7])
        except IOError:
            print(&#34;Error reading atom mass&#34;)
            sys.exit(&#39;mmtypes 9&#39;)

        except IOError:
            print(&#34;Error reading psf at atom %d&#34; % i)
            sys.exit()
    return mmNames</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.PSFFile.getNumAtoms"><code class="name flex">
<span>def <span class="ident">getNumAtoms</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Read the number of atoms from the PSF file
This leave the file at the NATOM line! Rewind it if you need to
go from beginning and don't change because other programs depend
on it!
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getNumAtoms(self):
    &#34;&#34;&#34;
    Read the number of atoms from the PSF file
    This leave the file at the NATOM line! Rewind it if you need to
    go from beginning and don&#39;t change because other programs depend
    on it!
    :return:
    &#34;&#34;&#34;
    self.ifi.seek(0)
    natoms = 0
    while True:
        line = self.ifi.readline()
        if not line:
            break
        if &#34;!NATOM&#34; in line:
            try:
                natoms = int(line.split()[0])
                break
            except IOError:
                print(&#34;Cannot read natoms from psf file&#34;)
                sys.exit()
    if natoms == 0:
        print(&#34;Could not find NATOM in psf file&#34;)
        raise IOError

    return natoms</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.PSFFile.getTopo"><code class="name flex">
<span>def <span class="ident">getTopo</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getTopo(self):
    topo = Topology()
    topo.mm_types = self.getMMTypes()
    topo.num_atoms = topo.mm_types.numAtoms
    return topo</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.PSFFile.read_beginning_lines"><code class="name flex">
<span>def <span class="ident">read_beginning_lines</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_beginning_lines(self):
        lines = []
        self.ifi.seek(0)
        line = &#34;&#34;
        found = False
        while found == False:
            line = self.ifi.readline()
            if &#34;!NBOND&#34; not in line:
                lines.append(line)
            else:
                found = True
        if not found:
            print(&#34;Error parsing PSF file for lines&#34;)
        return lines</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology"><code class="flex name class">
<span>class <span class="ident">Topology</span></span>
<span>(</span><span>of_path=None, num_atoms=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Topology:
    def __init__(self, of_path=None, num_atoms=0):
        self.hello = True
        self.bonds = []
        self.psf_lines = []
        self.num_atoms = 0
        self.ofi = None
        if of_path:
            self.set_ofi(of_path)
        self.mm_types = MMTypes(1)
        # if num_atoms:
            # self.ind = np.arange(1, num_atoms + 1, 1)
            # self.segment = np.array(num_atoms, dtype=&#39;U4&#39;)
            # self.resid = np.array(num_atoms, dtype=int)
            # self.resname = np.array(num_atoms, dtype=&#39;U4&#39;)
            # self.atmname = np.array(num_atoms, dtype=&#39;U4&#39;)
        # self.ind = []
        # self.resid = []
        # self.segname = []
        # self.resname = []
        # self.atmname = []
        # self.atmtype = []
        # self.charge = []
        # self.mass = []


    def set_ofi(self, of_path):
        if self.ofi:
            self.ofi.close()
        else:
            self.ofi = open(of_path, &#39;w&#39;)

    def close_ofi(self):
        self.ofi.close()
        self.ofi = None

    def write_psf(self, bonds, num_atoms, start_lines=None):
        num_bonds = len(bonds)
        num_ang = 0
        num_dihed = 0
        num_imp = 0
        num_don = 0
        num_acc = 0
        num_nnb = 0
        bond_tstr = &#34;{0:8d} !NBOND: bonds\n&#34;
        ang_tstr = &#34;{0:8d} !NTHETA: angles\n&#34;
        dihed_tstr = &#34;{0:8d} !NPHI: angles\n&#34;
        imp_tstr = &#34;{0:8d} !NIMPHI: angles\n&#34;
        don_tstr = &#34;{0:8d} !NDON: angles\n&#34;
        acc_tstr = &#34;{0:8d} !NACC: angles\n&#34;
        nnb_tstr = &#34;{0:8d} !NNB: angles\n\n&#34;
        ngrp = &#34;{:8d}{:8d} !NGRP\n{:8d}{:8d}{:8d}\n&#34;.format(1,0,0,0,0)

        if start_lines:
            self.ofi.writelines(start_lines)
        else:
            self.write_title()
            self.write_natom()
        self.write_section(bond_tstr, bonds, 4)
        # Write angles
        self.ofi.write(ang_tstr.format(num_ang))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(dihed_tstr.format(num_dihed))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(imp_tstr.format(num_imp))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(don_tstr.format(num_don))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(acc_tstr.format(num_acc))
        self.ofi.write(&#39;\n\n&#39;)
        self.ofi.write(nnb_tstr.format(num_nnb))
        self.ofi.write(&#39;\n\n&#39;)
        zeros = [[-1] for i in range(num_atoms)]
        self.write_section(nnb_tstr, zeros, 8)
        self.ofi.write(ngrp)
        self.close_ofi()

    def write_title(self):
        &#34;&#34;&#34;
        Write a title for the psf file
        :return:
        &#34;&#34;&#34;
        self.ofi.write(&#39;PSF\n\n&#39;)
        self.ofi.write(&#39;{0:8d} !NTITLE\n&#39;.format(1))
        self.ofi.write(&#39; REMARKS nothing\n\n&#39;)

    def write_natom(self):
        &#34;&#34;&#34;
        Write the mm atom types into the psf file
        :return:
        &#34;&#34;&#34;
        line = &#34;&#34;
        self.ofi.write(&#39;{:8d} !NATOM\n&#39;.format(self.mm_types.numAtoms))
        for i in range(self.mm_types.numAtoms):
            self.ofi.write(&#34;{:8d} &#34;    .format(i+1))
            self.ofi.write(&#34;{:4s} &#34;    .format(self.mm_types.segName[i]))
            self.ofi.write(&#34;{:&lt;4d} &#34;   .format(self.mm_types.resId[i]))
            self.ofi.write(&#34;{:4} &#34;     .format(self.mm_types.resName[i]))
            self.ofi.write(&#34;{:4} &#34;     .format(str(self.mm_types.atomName[i])))
            self.ofi.write(&#34;{:4} &#34;     .format(str(self.mm_types.atomType[i])))
            self.ofi.write(&#34;{:10.6f}  &#34;.format(self.mm_types.charge[i]))
            self.ofi.write(&#34;{:12.4f}&#34;  .format(self.mm_types.atomMass[i]))
            self.ofi.write(&#34;{:12d}\n&#34;  .format(0))
        self.ofi.write(&#39;\n&#39;)
        return

    def write_section(self, tstring, inds, groups_per_line):
        num_groups = len(inds)
        num_lines = num_groups // groups_per_line
        extra_bonds = num_groups % groups_per_line

        self.ofi.write(tstring.format(num_groups))
        g = 0
        gpl = groups_per_line
        for out_line in range(num_lines):
            my_str = self.make_str(inds[g:g+gpl])
            self.ofi.write(my_str)
            g += gpl
        if extra_bonds:
            my_str = self.make_str(inds[g:])
            self.ofi.write(my_str)
        self.ofi.write(&#39;\n\n&#39;)


    def make_str(self, inds, str_width=8):
        template = &#34;{:&#34; + str(str_width) + &#34;d}&#34;
        my_str = &#34;&#34;
        num_groups = len(inds)
        num_in_group = len(inds[0])
        for i in range(num_groups):
            for j in range(num_in_group):
                my_str += template
        my_str += &#39;\n&#39;
        flat_list = [item +1 for sublist in inds for item in sublist]
        return my_str.format(*flat_list)

    def write_mol2(self, bonds):


        self.ofi.write(&#39;@&lt;TRIPOS&gt;MOLECULE\n&#39;)
        self.ofi.write(&#39;*****\n&#39;)
        s = &#39; {0:d} {1:d} 0 0 0\n&#39;
        self.ofi.write(s.format(self.num_atoms, len(bonds)))
        self.ofi.write(&#39;SMALL\nGASTEIGER\n\n&#39;)
        self.write_atom()
        self.write_bond(bonds)
        self.close_ofi()

    def write_atom(self):
        self.ofi.write(&#39;@&lt;TRIPOS&gt;ATOM\n&#39;)
        atmstr = &#39;{0:7d} {1:2}          0.0000    0.0000    0.0000 {2:4} {5:&gt;4}  {3:5}       {4:7.4f}\n&#39;
        for i in range(self.mm_types.numAtoms):
            self.ofi.write(atmstr.format(i+1,
                                         self.mm_types.element[i],
                                         str(self.mm_types.atomType[i]),
                                         str(self.mm_types.atomName[i]),
                                         self.mm_types.charge[i],
                                         str(self.mm_types.resId[i])))
    def write_bond(self, bonds):
        self.ofi.write(&#39;@&lt;TRIPOS&gt;BOND\n&#39;)
        s = &#39;{:6d}{:6d}{:6d}{:6d}\n&#39;
        for i in range(len(bonds)):
            self.ofi.write(s.format(i+1, bonds[i][0]+1, bonds[i][1]+1, 1))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="adaptive_md_tools.mdtools.Topology.close_ofi"><code class="name flex">
<span>def <span class="ident">close_ofi</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def close_ofi(self):
    self.ofi.close()
    self.ofi = None</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.make_str"><code class="name flex">
<span>def <span class="ident">make_str</span></span>(<span>self, inds, str_width=8)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_str(self, inds, str_width=8):
    template = &#34;{:&#34; + str(str_width) + &#34;d}&#34;
    my_str = &#34;&#34;
    num_groups = len(inds)
    num_in_group = len(inds[0])
    for i in range(num_groups):
        for j in range(num_in_group):
            my_str += template
    my_str += &#39;\n&#39;
    flat_list = [item +1 for sublist in inds for item in sublist]
    return my_str.format(*flat_list)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.set_ofi"><code class="name flex">
<span>def <span class="ident">set_ofi</span></span>(<span>self, of_path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_ofi(self, of_path):
    if self.ofi:
        self.ofi.close()
    else:
        self.ofi = open(of_path, &#39;w&#39;)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.write_atom"><code class="name flex">
<span>def <span class="ident">write_atom</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_atom(self):
    self.ofi.write(&#39;@&lt;TRIPOS&gt;ATOM\n&#39;)
    atmstr = &#39;{0:7d} {1:2}          0.0000    0.0000    0.0000 {2:4} {5:&gt;4}  {3:5}       {4:7.4f}\n&#39;
    for i in range(self.mm_types.numAtoms):
        self.ofi.write(atmstr.format(i+1,
                                     self.mm_types.element[i],
                                     str(self.mm_types.atomType[i]),
                                     str(self.mm_types.atomName[i]),
                                     self.mm_types.charge[i],
                                     str(self.mm_types.resId[i])))</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.write_bond"><code class="name flex">
<span>def <span class="ident">write_bond</span></span>(<span>self, bonds)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_bond(self, bonds):
    self.ofi.write(&#39;@&lt;TRIPOS&gt;BOND\n&#39;)
    s = &#39;{:6d}{:6d}{:6d}{:6d}\n&#39;
    for i in range(len(bonds)):
        self.ofi.write(s.format(i+1, bonds[i][0]+1, bonds[i][1]+1, 1))</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.write_mol2"><code class="name flex">
<span>def <span class="ident">write_mol2</span></span>(<span>self, bonds)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_mol2(self, bonds):


    self.ofi.write(&#39;@&lt;TRIPOS&gt;MOLECULE\n&#39;)
    self.ofi.write(&#39;*****\n&#39;)
    s = &#39; {0:d} {1:d} 0 0 0\n&#39;
    self.ofi.write(s.format(self.num_atoms, len(bonds)))
    self.ofi.write(&#39;SMALL\nGASTEIGER\n\n&#39;)
    self.write_atom()
    self.write_bond(bonds)
    self.close_ofi()</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.write_natom"><code class="name flex">
<span>def <span class="ident">write_natom</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the mm atom types into the psf file
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_natom(self):
    &#34;&#34;&#34;
    Write the mm atom types into the psf file
    :return:
    &#34;&#34;&#34;
    line = &#34;&#34;
    self.ofi.write(&#39;{:8d} !NATOM\n&#39;.format(self.mm_types.numAtoms))
    for i in range(self.mm_types.numAtoms):
        self.ofi.write(&#34;{:8d} &#34;    .format(i+1))
        self.ofi.write(&#34;{:4s} &#34;    .format(self.mm_types.segName[i]))
        self.ofi.write(&#34;{:&lt;4d} &#34;   .format(self.mm_types.resId[i]))
        self.ofi.write(&#34;{:4} &#34;     .format(self.mm_types.resName[i]))
        self.ofi.write(&#34;{:4} &#34;     .format(str(self.mm_types.atomName[i])))
        self.ofi.write(&#34;{:4} &#34;     .format(str(self.mm_types.atomType[i])))
        self.ofi.write(&#34;{:10.6f}  &#34;.format(self.mm_types.charge[i]))
        self.ofi.write(&#34;{:12.4f}&#34;  .format(self.mm_types.atomMass[i]))
        self.ofi.write(&#34;{:12d}\n&#34;  .format(0))
    self.ofi.write(&#39;\n&#39;)
    return</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.write_psf"><code class="name flex">
<span>def <span class="ident">write_psf</span></span>(<span>self, bonds, num_atoms, start_lines=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_psf(self, bonds, num_atoms, start_lines=None):
    num_bonds = len(bonds)
    num_ang = 0
    num_dihed = 0
    num_imp = 0
    num_don = 0
    num_acc = 0
    num_nnb = 0
    bond_tstr = &#34;{0:8d} !NBOND: bonds\n&#34;
    ang_tstr = &#34;{0:8d} !NTHETA: angles\n&#34;
    dihed_tstr = &#34;{0:8d} !NPHI: angles\n&#34;
    imp_tstr = &#34;{0:8d} !NIMPHI: angles\n&#34;
    don_tstr = &#34;{0:8d} !NDON: angles\n&#34;
    acc_tstr = &#34;{0:8d} !NACC: angles\n&#34;
    nnb_tstr = &#34;{0:8d} !NNB: angles\n\n&#34;
    ngrp = &#34;{:8d}{:8d} !NGRP\n{:8d}{:8d}{:8d}\n&#34;.format(1,0,0,0,0)

    if start_lines:
        self.ofi.writelines(start_lines)
    else:
        self.write_title()
        self.write_natom()
    self.write_section(bond_tstr, bonds, 4)
    # Write angles
    self.ofi.write(ang_tstr.format(num_ang))
    self.ofi.write(&#39;\n\n&#39;)
    self.ofi.write(dihed_tstr.format(num_dihed))
    self.ofi.write(&#39;\n\n&#39;)
    self.ofi.write(imp_tstr.format(num_imp))
    self.ofi.write(&#39;\n\n&#39;)
    self.ofi.write(don_tstr.format(num_don))
    self.ofi.write(&#39;\n\n&#39;)
    self.ofi.write(acc_tstr.format(num_acc))
    self.ofi.write(&#39;\n\n&#39;)
    self.ofi.write(nnb_tstr.format(num_nnb))
    self.ofi.write(&#39;\n\n&#39;)
    zeros = [[-1] for i in range(num_atoms)]
    self.write_section(nnb_tstr, zeros, 8)
    self.ofi.write(ngrp)
    self.close_ofi()</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.write_section"><code class="name flex">
<span>def <span class="ident">write_section</span></span>(<span>self, tstring, inds, groups_per_line)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_section(self, tstring, inds, groups_per_line):
    num_groups = len(inds)
    num_lines = num_groups // groups_per_line
    extra_bonds = num_groups % groups_per_line

    self.ofi.write(tstring.format(num_groups))
    g = 0
    gpl = groups_per_line
    for out_line in range(num_lines):
        my_str = self.make_str(inds[g:g+gpl])
        self.ofi.write(my_str)
        g += gpl
    if extra_bonds:
        my_str = self.make_str(inds[g:])
        self.ofi.write(my_str)
    self.ofi.write(&#39;\n\n&#39;)</code></pre>
</details>
</dd>
<dt id="adaptive_md_tools.mdtools.Topology.write_title"><code class="name flex">
<span>def <span class="ident">write_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Write a title for the psf file
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_title(self):
    &#34;&#34;&#34;
    Write a title for the psf file
    :return:
    &#34;&#34;&#34;
    self.ofi.write(&#39;PSF\n\n&#39;)
    self.ofi.write(&#39;{0:8d} !NTITLE\n&#39;.format(1))
    self.ofi.write(&#39; REMARKS nothing\n\n&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="adaptive_md_tools" href="index.html">adaptive_md_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="adaptive_md_tools.mdtools.get_args" href="#adaptive_md_tools.mdtools.get_args">get_args</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.get_elements" href="#adaptive_md_tools.mdtools.get_elements">get_elements</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.main" href="#adaptive_md_tools.mdtools.main">main</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.print_xyz" href="#adaptive_md_tools.mdtools.print_xyz">print_xyz</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.print_xyz_traj" href="#adaptive_md_tools.mdtools.print_xyz_traj">print_xyz_traj</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.rawincount" href="#adaptive_md_tools.mdtools.rawincount">rawincount</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.read_xyz" href="#adaptive_md_tools.mdtools.read_xyz">read_xyz</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.read_xyz2" href="#adaptive_md_tools.mdtools.read_xyz2">read_xyz2</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.read_xyz_trajectory" href="#adaptive_md_tools.mdtools.read_xyz_trajectory">read_xyz_trajectory</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.testGroups" href="#adaptive_md_tools.mdtools.testGroups">testGroups</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.testPSFBonds" href="#adaptive_md_tools.mdtools.testPSFBonds">testPSFBonds</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.wrap_coords" href="#adaptive_md_tools.mdtools.wrap_coords">wrap_coords</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.Bonds" href="#adaptive_md_tools.mdtools.Bonds">Bonds</a></code></h4>
<ul class="">
<li><code><a title="adaptive_md_tools.mdtools.Bonds.addBonds" href="#adaptive_md_tools.mdtools.Bonds.addBonds">addBonds</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Bonds.getUniqueBonds" href="#adaptive_md_tools.mdtools.Bonds.getUniqueBonds">getUniqueBonds</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Bonds.printBonds" href="#adaptive_md_tools.mdtools.Bonds.printBonds">printBonds</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.File" href="#adaptive_md_tools.mdtools.File">File</a></code></h4>
</li>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.Groups" href="#adaptive_md_tools.mdtools.Groups">Groups</a></code></h4>
<ul class="">
<li><code><a title="adaptive_md_tools.mdtools.Groups.checkGroups" href="#adaptive_md_tools.mdtools.Groups.checkGroups">checkGroups</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Groups.printGroups" href="#adaptive_md_tools.mdtools.Groups.printGroups">printGroups</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Groups.setAtomGroup" href="#adaptive_md_tools.mdtools.Groups.setAtomGroup">setAtomGroup</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Groups.setGroupRep" href="#adaptive_md_tools.mdtools.Groups.setGroupRep">setGroupRep</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Groups.transferAtom" href="#adaptive_md_tools.mdtools.Groups.transferAtom">transferAtom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.GroupsFile" href="#adaptive_md_tools.mdtools.GroupsFile">GroupsFile</a></code></h4>
<ul class="">
<li><code><a title="adaptive_md_tools.mdtools.GroupsFile.getGroups" href="#adaptive_md_tools.mdtools.GroupsFile.getGroups">getGroups</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.MMTypes" href="#adaptive_md_tools.mdtools.MMTypes">MMTypes</a></code></h4>
</li>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.Mol2File" href="#adaptive_md_tools.mdtools.Mol2File">Mol2File</a></code></h4>
<ul class="two-column">
<li><code><a title="adaptive_md_tools.mdtools.Mol2File.getBonds" href="#adaptive_md_tools.mdtools.Mol2File.getBonds">getBonds</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Mol2File.getMMTypes" href="#adaptive_md_tools.mdtools.Mol2File.getMMTypes">getMMTypes</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Mol2File.getNumAtoms" href="#adaptive_md_tools.mdtools.Mol2File.getNumAtoms">getNumAtoms</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Mol2File.getTopo" href="#adaptive_md_tools.mdtools.Mol2File.getTopo">getTopo</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Mol2File.read_atom" href="#adaptive_md_tools.mdtools.Mol2File.read_atom">read_atom</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Mol2File.read_bonds" href="#adaptive_md_tools.mdtools.Mol2File.read_bonds">read_bonds</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.PDBFile" href="#adaptive_md_tools.mdtools.PDBFile">PDBFile</a></code></h4>
<ul class="">
<li><code><a title="adaptive_md_tools.mdtools.PDBFile.parsePDB" href="#adaptive_md_tools.mdtools.PDBFile.parsePDB">parsePDB</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.PSFFile" href="#adaptive_md_tools.mdtools.PSFFile">PSFFile</a></code></h4>
<ul class="">
<li><code><a title="adaptive_md_tools.mdtools.PSFFile.getBonds" href="#adaptive_md_tools.mdtools.PSFFile.getBonds">getBonds</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.PSFFile.getMMTypes" href="#adaptive_md_tools.mdtools.PSFFile.getMMTypes">getMMTypes</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.PSFFile.getNumAtoms" href="#adaptive_md_tools.mdtools.PSFFile.getNumAtoms">getNumAtoms</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.PSFFile.getTopo" href="#adaptive_md_tools.mdtools.PSFFile.getTopo">getTopo</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.PSFFile.read_beginning_lines" href="#adaptive_md_tools.mdtools.PSFFile.read_beginning_lines">read_beginning_lines</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="adaptive_md_tools.mdtools.Topology" href="#adaptive_md_tools.mdtools.Topology">Topology</a></code></h4>
<ul class="two-column">
<li><code><a title="adaptive_md_tools.mdtools.Topology.close_ofi" href="#adaptive_md_tools.mdtools.Topology.close_ofi">close_ofi</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.make_str" href="#adaptive_md_tools.mdtools.Topology.make_str">make_str</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.set_ofi" href="#adaptive_md_tools.mdtools.Topology.set_ofi">set_ofi</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.write_atom" href="#adaptive_md_tools.mdtools.Topology.write_atom">write_atom</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.write_bond" href="#adaptive_md_tools.mdtools.Topology.write_bond">write_bond</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.write_mol2" href="#adaptive_md_tools.mdtools.Topology.write_mol2">write_mol2</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.write_natom" href="#adaptive_md_tools.mdtools.Topology.write_natom">write_natom</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.write_psf" href="#adaptive_md_tools.mdtools.Topology.write_psf">write_psf</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.write_section" href="#adaptive_md_tools.mdtools.Topology.write_section">write_section</a></code></li>
<li><code><a title="adaptive_md_tools.mdtools.Topology.write_title" href="#adaptive_md_tools.mdtools.Topology.write_title">write_title</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>